"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[249],{4133:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=i(4848),t=i(8453);const a={title:"Case Study",description:"Cerebellum Case Study",toc_min_heading_level:2,toc_max_heading_level:3,className:"test"},r="Case Study",o={type:"mdx",permalink:"/case-study",source:"@site/src/pages/case-study.md",title:"Case Study",description:"Cerebellum Case Study",frontMatter:{title:"Case Study",description:"Cerebellum Case Study",toc_min_heading_level:2,toc_max_heading_level:3,className:"test"},unlisted:!1},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Background: Realtime",id:"background-realtime",level:2},{value:"Realtime Categories",id:"realtime-categories",level:3},{value:"Realtime Techniques &amp; Technologies",id:"realtime-techniques--technologies",level:3},{value:"WebSockets",id:"websockets",level:4},{value:"WebTransport",id:"webtransport",level:4},{value:"Scaling WebSocket Applications is Not Trivial",id:"scaling-websocket-applications-is-not-trivial",level:3},{value:"Challenges with State",id:"challenges-with-state",level:4},{value:"Challenges with Performance",id:"challenges-with-performance",level:4},{value:"Dedicated Realtime Infrastructure",id:"dedicated-realtime-infrastructure",level:4},{value:"Cerebellum&#39;s Niche",id:"cerebellums-niche",level:2},{value:"Building Cerebellum\u2019s Infrastructure",id:"building-cerebellums-infrastructure",level:2},{value:"Establishing a Connection on a Single Server",id:"establishing-a-connection-on-a-single-server",level:3},{value:"Scaling Complexities with Multiple Servers",id:"scaling-complexities-with-multiple-servers",level:3},{value:"Scalable Servers",id:"scalable-servers",level:4},{value:"Pub/Sub",id:"pubsub",level:4},{value:"Redis Streams as Our Pub/Sub System",id:"redis-streams-as-our-pubsub-system",level:4},{value:"Balancing the Load Distribution",id:"balancing-the-load-distribution",level:4},{value:"Persisting Data in a Realtime Application",id:"persisting-data-in-a-realtime-application",level:3},{value:"Choosing the Right Database for Realtime Applications",id:"choosing-the-right-database-for-realtime-applications",level:4},{value:"Availability vs. Consistency",id:"availability-vs-consistency",level:4},{value:"Archiving Data",id:"archiving-data",level:4},{value:"HTTP Endpoint",id:"http-endpoint",level:3},{value:"Implementation of API Gateway and AWS Lambda",id:"implementation-of-api-gateway-and-aws-lambda",level:4},{value:"Integration with DynamoDB and Other Services",id:"integration-with-dynamodb-and-other-services",level:4},{value:"Final Architecture",id:"final-architecture",level:3},{value:"Realtime Engineering Challenges",id:"realtime-engineering-challenges",level:2},{value:"Sticky Sessions",id:"sticky-sessions",level:3},{value:"Connection State Recovery",id:"connection-state-recovery",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Token-Based Authentication",id:"token-based-authentication",level:4},{value:"Presence",id:"presence",level:3},{value:"Utilizing ElastiCache for Presence",id:"utilizing-elasticache-for-presence",level:4},{value:"How to Handle Disconnections",id:"how-to-handle-disconnections",level:4},{value:"Load Testing",id:"load-testing",level:2},{value:"Terminology",id:"terminology",level:4},{value:"1) Limit of Concurrent Idle Users",id:"1-limit-of-concurrent-idle-users",level:4},{value:"2) Limit of Concurrent Active Users",id:"2-limit-of-concurrent-active-users",level:4},{value:"Calculations",id:"calculations",level:4},{value:"Conclusion",id:"conclusion",level:4},{value:"In the Pipeline...",id:"in-the-pipeline",level:2},{value:"Archived Message Retrieval",id:"archived-message-retrieval",level:4},{value:"Rate Limiting",id:"rate-limiting",level:4},{value:"ElastiCache: Load Testing and Failover",id:"elasticache-load-testing-and-failover",level:4},{value:"Cloud-Agnostic Offering",id:"cloud-agnostic-offering",level:4}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"case-study",children:"Case Study"}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Cerebellum is a drop-in infrastructure and library for scalable realtime applications. Whether starting from scratch or integrating an existing application, Cerebellum enables developers to move from development to fully scalable deployment in just a few simple steps."}),"\n",(0,s.jsx)(n.p,{children:"Alongside our ready-made infrastructure, we offer a Software Development Kit (SDK) and a production-ready WebSocket server, empowering developers to deploy quickly and efficiently without the hassle of managing cloud platforms or connections."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/Full_Infrastructure_Diagram.png",className:"diagram",alt:"Cerebellum Infrastructure",width:"85%"}),(0,s.jsx)("figcaption",{align:"center",children:"Cerebellum's Complete Infrastructure"})]}),"\n",(0,s.jsx)(n.h2,{id:"background-realtime",children:"Background: Realtime"}),"\n",(0,s.jsxs)(n.p,{children:["Let\u2019s take a step back to understand the concept of realtime. Realtime is the ",(0,s.jsx)(n.em,{children:"instantaneous"})," exchange of data. Instantaneous in computing terms means to be ",(0,s.jsx)(n.em,{children:"perceived"})," as instantaneous. This metric can vary depending on the constraints of the application, but instantaneous is commonly considered to be ",(0,s.jsx)(n.a,{href:"https://www.pubnub.com/blog/how-fast-is-realtime-human-perception-and-technology/",children:"below 100-millisecond latency"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Realtime applications are divided into two main categories, each with distinct time constraints or \u201cdeadlines\u201d that must be met to ensure a proper response."}),"\n",(0,s.jsx)(n.h3,{id:"realtime-categories",children:"Realtime Categories"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hard realtime"})," applications demand absolute performance where timing is crucial, and deadlines ",(0,s.jsx)(n.strong,{children:"must"})," be met without exception. Missing a deadline in a hard realtime system can lead to total system failure and catastrophic consequences, often involving safety hazards or physical damage. The importance of a task is directly tied to meeting its deadline; missing it can render the task's value null. Examples of such systems include emergency medical devices, industrial automation systems, and flight control systems."]}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.strong,{children:"soft realtime"})," applications, missing a deadline results in a degradation of service quality, which can negatively impact user experience and be quite frustrating. However, it does not lead to system failure or significant harm. The value of a task is somewhat correlated with meeting the deadline\u2014if missed, the value decreases but does not become null. Examples of soft realtime systems include messaging apps, online multiplayer games, and collaborative editors. ",(0,s.jsx)(n.em,{children:"Cerebellum is designed specifically for soft realtime applications."})]}),"\n",(0,s.jsxs)("div",{className:"flex flex-row multi-image-container",children:[(0,s.jsxs)("figure",{className:"image-container flex-1 flex-grow",children:[(0,s.jsx)("img",{src:"/case-study/photos/Hard_Realtime.png",className:"diagram",alt:"Hard Realtime",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Hard Realtime"})]}),(0,s.jsxs)("figure",{className:"image-container flex-1 flex-grow",children:[(0,s.jsx)("img",{src:"/case-study/photos/Soft_Realtime.png",className:"diagram",alt:"Soft Realtime",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Hard Realtime"})]})]}),"\n",(0,s.jsx)(n.p,{children:"Before we dive deeper into Cerebellum, we need to review a few key techniques and technologies for building realtime web applications."}),"\n",(0,s.jsx)(n.h3,{id:"realtime-techniques--technologies",children:"Realtime Techniques & Technologies"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Short polling"})," involves sending HTTP requests at intervals to check for new data. While simple to implement, it can create unnecessary network traffic and server load when no new updates are available."]}),"\n",(0,s.jsxs)("figure",{className:"image-container mobile-single-image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/ShortPolling_Diagram.png",className:"diagram",alt:"Short Polling",width:"30%"}),(0,s.jsx)("figcaption",{align:"center",children:"Short Polling"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Long polling"})," improves on this by keeping the connection open until new data arrives, reducing redundant requests. However, it still requires the client to initiate each new request, which can lead to occasional synchronization issues."]}),"\n",(0,s.jsxs)("figure",{className:"image-container mobile-single-image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/LongPolling_Diagram.png",className:"diagram",alt:"Long Polling",width:"30%"}),(0,s.jsx)("figcaption",{align:"center",children:"Long Polling"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Server-Sent Events"})," (SSEs) further optimize this process by maintaining an open connection where the server continuously pushes updates to the client as they become available, eliminating the need for repeated requests and minimizing latency."]}),"\n",(0,s.jsxs)("figure",{className:"image-container mobile-single-image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/SSE_Diagram.png",className:"diagram",alt:"Server-Sent Events",width:"30%"}),(0,s.jsx)("figcaption",{align:"center",children:"Server-Sent Events"})]}),"\n",(0,s.jsx)(n.p,{children:"While SSEs are efficient for one-way updates, they do not allow the client to send data back to the server in the same connection. This is where WebSockets excel."}),"\n",(0,s.jsx)(n.h4,{id:"websockets",children:"WebSockets"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"WebSocket"})," protocol offers full-duplex communication over a single long-lived Transmission Control Protocol (TCP) connection. After an initial \u201chandshake\u201d to establish the connection, a dedicated low-latency channel is created, allowing for ",(0,s.jsx)(n.em,{children:"instantaneous"})," data exchange in ",(0,s.jsx)(n.em,{children:"both"})," directions."]}),"\n",(0,s.jsxs)("figure",{className:"image-container mobile-single-image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/WebSocket_Diagram1.png",className:"diagram",alt:"WebSocket Diagram",width:"30%"}),(0,s.jsx)("figcaption",{align:"center",children:"WebSocket Connection"})]}),"\n",(0,s.jsx)(n.p,{children:"However, WebSockets are complex to set up and manage due to their persistent connection and stateful nature. WebSockets require both browser and server-side support, but their long-standing presence means they are widely compatible across platforms. Additionally, WebSockets suffer from head-of-line blocking, where delays in one message can impact the delivery of subsequent messages."}),"\n",(0,s.jsx)(n.h4,{id:"webtransport",children:"WebTransport"}),"\n",(0,s.jsx)(n.p,{children:"The WebTransport API is an emerging technology that offers a promising alternative to WebSockets. WebTransport utilizes multiplexed streams and datagrams over HTTP/3 and the QUIC protocol. This setup allows multiple data streams to function independently within the same connection, reducing latency and avoiding head-of-line blocking\u2014a problem in single-stream systems like WebSockets where delays in one packet can affect all subsequent packets. WebTransport\u2019s capabilities make it particularly effective for handling numerous simultaneous realtime data exchanges, such as video streaming or complex online games."}),"\n",(0,s.jsx)(n.p,{children:"However, WebTransport is still in development and lacks support across all browsers. It also requires server-side support, which is not yet as widely available as WebSocket support."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/CommunicationComparisonChart.png",className:"diagram",alt:"Realtime Comparison Chart",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Realtime Techniques & Technologies"})]}),"\n",(0,s.jsx)(n.p,{children:"We determined that WebSockets are the most suitable for our focus and application. However, WebSockets come with distinct complexities, particularly when it comes to scaling."}),"\n",(0,s.jsx)(n.h3,{id:"scaling-websocket-applications-is-not-trivial",children:"Scaling WebSocket Applications is Not Trivial"}),"\n",(0,s.jsx)(n.p,{children:"Scaling web applications typically involves vertical scaling, horizontal scaling, or some combination thereof. Vertical scaling involves adding more power to a single server, while horizontal scaling spreads the load across multiple servers."}),"\n",(0,s.jsxs)("div",{className:"flex justify-center video-container",children:[(0,s.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,s.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,s.jsx)("video",{src:"/case-study/videos/vertical_scale_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:" w-full rounded-lg"})}),(0,s.jsx)("figcaption",{align:"center",children:"Vertical Scaling"})]}),(0,s.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,s.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,s.jsx)("video",{src:"/case-study/videos/horizontal_scaling_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"flex-grow w-full rounded-lg"})}),(0,s.jsx)("figcaption",{align:"center",children:"Horizontal Scaling"})]})]}),"\n",(0,s.jsx)(n.p,{children:"Scaling realtime WebSocket applications comes with an additional set of unique challenges. It\u2019s helpful to use HTTP-based applications as a benchmark to understand these challenges."}),"\n",(0,s.jsx)(n.h4,{id:"challenges-with-state",children:"Challenges with State"}),"\n",(0,s.jsx)(n.p,{children:"One of the main differences between HTTP-based applications and WebSocket applications relates to state. In an HTTP interaction, the client initiates a request to the server, which processes the request and sends back a response, after which the connection is terminated. This type of communication is considered stateless because each request is independent and doesn\u2019t rely on information from previous interactions. Because HTTP-based applications are stateless, any server can handle any request, making horizontal scaling more straightforward."}),"\n",(0,s.jsx)(n.p,{children:"WebSocket applications differ by maintaining an ongoing connection between the client and server, requiring each server to manage the session state and route messages accordingly. This continuity complicates scaling, as servers need to coordinate which clients are connected to them. Unlike HTTP, WebSockets require more infrastructure to maintain these persistent connections."}),"\n",(0,s.jsxs)("div",{className:"flex justify-center video-container",children:[(0,s.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,s.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,s.jsx)("video",{src:"/case-study/videos/client_server_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:" w-full"})}),(0,s.jsx)("figcaption",{align:"center",children:"Single Server Managing Connection State"})]}),(0,s.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,s.jsx)("video",{src:"/case-study/videos/client_server_msg_lost_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"flex-grow w-full rounded-lg"}),(0,s.jsx)("figcaption",{align:"center",children:"Multiple Servers without Infrastructure for Connection State Management"})]})]}),"\n",(0,s.jsx)(n.h4,{id:"challenges-with-performance",children:"Challenges with Performance"}),"\n",(0,s.jsx)(n.p,{children:"Servers managing WebSocket connections face a heavier workload than those handling standard HTTP requests. WebSockets\u2019 ongoing connections increase resource consumption, especially memory and CPU. This can lead to performance issues and a poor user experience if not properly managed."}),"\n",(0,s.jsx)(n.p,{children:'Some applications add realtime features to existing servers that also handle non-realtime tasks. While simple, this "tightly coupled" approach introduces risks as the app scales:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Bottlenecks:"})," Shared resources can slow down both realtime and non-realtime tasks."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scaling Challenges:"})," Realtime and non-realtime components may need to scale differently, making management harder."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Point of Failure:"})," A failure in the server affects both components, increasing downtime risks."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Decoupling the realtime and non-realtime components allows each to scale independently, improving performance and reliability as the application grows."}),"\n",(0,s.jsx)(n.h4,{id:"dedicated-realtime-infrastructure",children:"Dedicated Realtime Infrastructure"}),"\n",(0,s.jsx)(n.p,{children:"Scaling WebSocket applications effectively requires specialized infrastructure. However, sourcing, configuring, and maintaining such infrastructure can be a significant burden for developers, diverting attention away from core product development. A dedicated infrastructure for realtime communication not only alleviates these challenges but also ensures that both performance and state management are optimized for the unique demands of WebSocket applications."}),"\n",(0,s.jsx)(n.h2,{id:"cerebellums-niche",children:"Cerebellum's Niche"}),"\n",(0,s.jsx)(n.p,{children:"For teams with a core focus on realtime, DIY solutions like Node.js' WebSocket library or Socket.io offer complete control and flexibility over data and infrastructure. However, these solutions require significant effort to set up and maintain."}),"\n",(0,s.jsx)(n.p,{children:"If realtime isn't your core product, third-party solutions like Ably or PartyKit can simplify integration and reduce setup time. These services handle infrastructure and offer easy-to-use abstractions but provide less control over data and customization."}),"\n",(0,s.jsx)(n.p,{children:"Cerebellum bridges the gap for teams seeking a balance between low effort, high flexibility, and full control over their data."}),"\n",(0,s.jsx)(n.p,{children:"To help evaluate solutions, we considered several key attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Persistence:"})," Duration and method of storing messages across sessions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User Presence:"})," Capability to track and report user status in real time."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open Source:"})," Availability of source code for inspection and modification."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Ownership:"})," Control over the data generated and stored."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exactly Once Delivery:"})," Assurance that messages are delivered exactly once."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Auto Scaling:"})," Ability to automatically adjust resources based on demand."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Language Support:"})," Compatibility with different programming languages."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cost:"})," Overall expenses related to using and scaling the service."]}),"\n"]}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/Product_Comparison_Chart.png",className:"diagram",alt:"Realtime Solution Comparison Chart",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Comparing Solutions"})]}),"\n",(0,s.jsx)(n.p,{children:"*Ably stores all messages for two minutes out of the box, with an option to increase to 72 hours in their premium package. Longer data persistence requires a third-party solution."}),"\n",(0,s.jsx)(n.p,{children:"Cerebellum is built for small to medium-sized development teams who want a realtime solution that handles infrastructure with strong support for data persistence, long-term storage, and an easy-to-use interface."}),"\n",(0,s.jsx)(n.h2,{id:"building-cerebellums-infrastructure",children:"Building Cerebellum\u2019s Infrastructure"}),"\n",(0,s.jsx)(n.p,{children:"Cerebellum was built with scaling in mind. This required provisioning servers for horizontal scaling, ensuring our architecture could maintain performance and reliability as the number of WebSocket connections increased."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://www.ibm.com/topics/cap-theorem",children:"CAP theorem"})," highlights a fundamental trade-off in distributed systems: they can prioritize either availability or consistency, but not both simultaneously. Availability ensures that data requests always receive a response, even if parts of the system fail. Consistency guarantees that all clients see the same data, which can sometimes come at the expense of longer load times."]}),"\n",(0,s.jsx)(n.p,{children:"Since Cerebellum is designed for soft realtime applications, we prioritize availability over consistency."}),"\n",(0,s.jsxs)(n.p,{children:["We chose AWS as our preferred platform to host the infrastructure, due to its extensive service offerings and ",(0,s.jsx)(n.a,{href:"https://www.statista.com/chart/18819/worldwide-market-share-of-leading-cloud-infrastructure-service-providers/",children:"dominant market share"})," among cloud providers."]}),"\n",(0,s.jsx)(n.h3,{id:"establishing-a-connection-on-a-single-server",children:"Establishing a Connection on a Single Server"}),"\n",(0,s.jsx)(n.p,{children:"We initially built our infrastructure with a single WebSocket server, allowing us to simplify development and focus on creating a stable realtime communication library."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/buildingCB_OneServer.png",className:"diagram",alt:"Illustration of clients connecting to a single server",width:"35%"}),(0,s.jsx)("figcaption",{align:"center",children:"Single-Server Connections"})]}),"\n",(0,s.jsx)(n.p,{children:"We hosted our WebSocket application on a server with 0.25 vCPU and 0.5 GB of RAM. When we exceeded 4,000 concurrent users, CPU utilization was nearing 70%, which is AWS\u2019s recommended threshold for scaling. Beyond this point, server response times could increase, and the risk of crashes becomes higher without additional resources. Moreover, relying on a single server introduces a single point of failure."}),"\n",(0,s.jsx)(n.h3,{id:"scaling-complexities-with-multiple-servers",children:"Scaling Complexities with Multiple Servers"}),"\n",(0,s.jsx)(n.h4,{id:"scalable-servers",children:"Scalable Servers"}),"\n",(0,s.jsx)(n.p,{children:"We used AWS Elastic Container Service (ECS) with AWS Fargate to set up our infrastructure for horizontal scaling. Containers are lightweight, portable units that package an application and its dependencies. These containers are created from images, which are snapshots of the application environment, including the code, libraries, and system settings."}),"\n",(0,s.jsx)(n.p,{children:"ECS is an orchestrator\u2014it manages the number of containers running at any given time. ECS monitors server load and decides when to scale up or down accordingly. Fargate is a compute engine that eliminates the need to provision and manage servers by creating serverless containers on demand. It allows us to define a Docker or Elastic Container Registry image (our WebSocket server by default) and creates a container with a pre-specified operating system."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/buildingCB_ECSCluster.png",className:"diagram",alt:"Illustration of two clients connecting to a cluster of servers",width:"45%"}),(0,s.jsx)("figcaption",{align:"center",children:"Multi-Server Connections"})]}),"\n",(0,s.jsx)(n.p,{children:"While our infrastructure could now automatically scale based on user load, users connected to different servers couldn't communicate with each other. Each server maintained its own isolated state and connection data. As a result, a user connected to one server wouldn't be able to reach a user connected to a different server."}),"\n",(0,s.jsx)(n.p,{children:"We needed a way for data to allow data flow and consistency between our servers. We implemented a pub/sub to facilitate this cross-server communication."}),"\n",(0,s.jsx)(n.h4,{id:"pubsub",children:"Pub/Sub"}),"\n",(0,s.jsx)(n.p,{children:"Publish/Subscribe (Pub/Sub) is a messaging pattern used in distributed systems to facilitate communication between different components. For context around this discussion, we\u2019ll define some key terms related to the pub/sub model:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Channels"}),' (also known as "rooms" or "topics") are communication hubs where messages are exchanged between publishers and subscribers.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Subscribers"})," are users or systems that receive notifications when a message is sent to a channel they follow."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Publishers"})," are users or systems that send messages to channels."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the pub/sub model, publishers and subscribers are decoupled. Publishers can send messages to channels without needing to know who the subscribers are, and subscribers receive messages without knowing who the publishers are."}),"\n",(0,s.jsx)(n.p,{children:"By implementing a pub/sub system, when a user sends a message to a server, it is received by the pub/sub system and forwarded to all subscribers of that channel, regardless of which server they are connected to. This ensures that all users receive the same information in real time, overcoming the challenges of server isolation and ensuring consistent message delivery across multiple servers."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/ChannelsPubSub.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Illustration of a User Posting a Message to a Channel"})]}),"\n",(0,s.jsx)(n.h4,{id:"redis-streams-as-our-pubsub-system",children:"Redis Streams as Our Pub/Sub System"}),"\n",(0,s.jsx)(n.p,{children:"For our pub/sub system, we used AWS ElastiCache for Redis, specifically utilizing Redis Streams. While Redis is often known for its key/value cache functionality, it also offers powerful features for building robust pub/sub systems."}),"\n",(0,s.jsx)(n.p,{children:"Redis Streams provides an append-only log data structure that supports more complex pub/sub scenarios. Key advantages include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persistence:"})," Messages in Redis Streams can be persisted, enabling replay and recovery, which is crucial for maintaining the connection state in realtime applications (a key requirement which we will discuss in detail in the ",(0,s.jsx)(n.a,{href:"#realtime-engineering-challenges",children:"Realtime Engineering Challenges"})," section)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Backpressure Handling:"})," Streams allow servers to regulate the rate of message consumption, preventing overload by controlling the flow of incoming messages."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We selected Redis Streams due to the high availability and low latency provided by AWS ElastiCache."}),"\n",(0,s.jsx)(n.p,{children:"In our Redis Streams implementation, the message flow differs slightly from traditional pub/sub systems. When a message is published, it is appended to a Redis Stream associated with a specific channel or topic. Each message is stored with a unique ID, ensuring persistence. Servers act as consumers, reading from these streams at their own pace and capacity. After retrieving messages, servers forward them to clients subscribed to the respective channels. This retains the core principles of a traditional pub/sub while also enabling data persistence."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/Redis_Streams.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Illustration of Servers Reading a New Message from Redis Streams"})]}),"\n",(0,s.jsx)(n.p,{children:"With our Redis Streams-based pub/sub system in place, we had to establish a single, secure public entry point while balancing load across multiple servers."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/buildingCB_Elasticache.png",className:"diagram",alt:"Illustration of multiple clients connecting to a cluster of servers using Redis Streams as a pub/sub system",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Multi-Server Connections with Redis Streams"})]}),"\n",(0,s.jsx)(n.h4,{id:"balancing-the-load-distribution",children:"Balancing the Load Distribution"}),"\n",(0,s.jsx)(n.p,{children:"Realtime applications require high availability and fault tolerance to ensure seamless user experiences, even during partial system failures. We use an Application Load Balancer (ALB) to distribute incoming traffic across multiple servers to achieve this. The ALB prevents any server from becoming overwhelmed and enhances overall performance and reliability."}),"\n",(0,s.jsx)(n.p,{children:"We considered a few options for routing traffic:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Round Robin:"})," Distributes each request sequentially to the next server. This method works well when traffic is uniform and servers have similar processing power."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Least Outstanding Requests:"})," Routes traffic to the server with the fewest active connections. This is ideal when request processing times vary and servers have different capabilities."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Since our infrastructure scales by duplicating containers with identical processing power, we initially considered Round Robin. However, we cannot anticipate uniform traffic in the realtime applications. Additionally, when new servers are spun up, we need to route traffic more heavily to them to utilize their increased capacity. Therefore, Least Outstanding Requests was our top choice to ensure a more balanced load across servers."}),"\n",(0,s.jsx)(n.p,{children:"In addition to balancing load, the ALB provides other key benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Health Checks"}),": The ALB tracks which servers are healthy/unhealthy and re-routes traffic accordingly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SSL/TLS Encryptions"}),": The ALB enforces encryption to protect data between client and server."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By handling these tasks, the ALB solved a crucial part of our infrastructure needs, ensuring the stability and security of our realtime applications while managing server load."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/buildingCB_LoadBalancer.png",className:"diagram",alt:"Illustration of a load balancer routing traffic to multiple servers",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Cerebellum's Infrastructure with an Application Load Balancer"})]}),"\n",(0,s.jsx)(n.h3,{id:"persisting-data-in-a-realtime-application",children:"Persisting Data in a Realtime Application"}),"\n",(0,s.jsx)(n.p,{children:"At this stage, our architecture successfully provided realtime scaling and communication, but we recognized a major limitation in the need for historical data access. This is vital for various realtime applications, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collaborative Editors:"})," Applications like Google Docs need to maintain past revisions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Video Conferencing:"})," Services like Zoom provide video recording features."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Communication Apps:"})," Platforms like Slack require persistent message history."]}),"\n"]}),"\n",(0,s.jsx)("figure",{className:"image-container",children:(0,s.jsx)("video",{src:"/case-study/videos/MessageHistory.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "})}),"\n",(0,s.jsx)("figcaption",{align:"center",children:"Illustration of a Communication App without Data Persistence"}),"\n",(0,s.jsx)(n.h4,{id:"choosing-the-right-database-for-realtime-applications",children:"Choosing the Right Database for Realtime Applications"}),"\n",(0,s.jsx)(n.p,{children:"Considerations when selecting a database for realtime applications were scalability, low latency, high throughput, and flexibility\u2014specifically regarding dynamic data structures. Because these were our major considerations, we ruled out SQL databases, which are more rigid in structure and require complex partitioning when scaling."}),"\n",(0,s.jsx)(n.p,{children:"With these in mind, we chose AWS DynamoDB. DynamoDB\u2019s ability to distribute data across multiple servers allows for smooth expansion as user bases grow, ensuring that Cerebellum-powered applications remain responsive even under heavy traffic. Its optimized read and write operations are crucial for handling the high throughput required in realtime scenarios. Moreover, DynamoDB\u2019s flexible schema supports the dynamic and evolving data models typical in realtime application development. For these reasons, DynamoDB offers an excellent blend of scalability, performance, and adaptability, making it well-suited to our needs."}),"\n",(0,s.jsx)(n.h4,{id:"availability-vs-consistency",children:"Availability vs. Consistency"}),"\n",(0,s.jsx)(n.p,{children:"With our database solution in place, we were faced with balancing availability and consistency in our realtime data interactions. This balance is essential for maintaining the responsiveness expected in realtime applications while ensuring data integrity."}),"\n",(0,s.jsx)(n.p,{children:"Direct communication between servers and databases in a realtime environment is straightforward and ensures strong consistency, but it also poses several issues:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Increased Latency:"})," Each database operation requires a round trip between the server and the database, adding delays that can be detrimental in realtime applications where milliseconds matter."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Connection Overhead:"})," Maintaining numerous open database connections for each user session can strain server and database resources, leading to inefficiencies."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Database Bottlenecks:"})," High-volume realtime applications can overwhelm databases with rapid read/write requests, potentially causing performance degradation or system failures."]}),"\n"]}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/Writing_to_DB.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Strong Consistency System: Writing Data to a Database"})]}),"\n",(0,s.jsx)(n.p,{children:"While this method ensures data consistency, the resulting latency and resource strain make it less suited for realtime applications where immediate responsiveness is optimal."}),"\n",(0,s.jsx)(n.p,{children:"We implemented a queue system between the servers and the database, using AWS Simple Queue Services and AWS Lambda. This approach offers several key benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Decoupling:"})," The queue buffers operations, letting the realtime server respond to clients without waiting for the database, ensuring quick responses."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Responsiveness:"})," Servers can process and acknowledge client requests promptly, meeting realtime app expectations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Managed Load:"})," The queue controls data flow to the database, preventing performance issues from sudden write bursts."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resilience:"})," If the database fails temporarily, the queue holds data until it's ready, minimizing data loss risk."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Eventual Consistency:"})," While not immediately consistent, the queue ensures all data is eventually processed, preserving integrity."]}),"\n"]}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/Writing_to_Queue.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Strong Availability System: Writing Data to a Queue"})]}),"\n",(0,s.jsx)(n.p,{children:"When a client sends data to Cerebellum servers, the server will immediately timestamp the message and send it to the queue. The server continues to process the request without waiting for a confirmation from the database. When the message reaches the front of the queue, a serverless function will process the message and save it to the database. If the database write fails, the queue can retry the operation or save the data in the dead-letter queue\u2014a special queue where undeliverable or failed messages are sent, allowing developers to analyze and fix issues. This ensures data is not lost."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/buildingCB_DB_and_Queue.png",className:"diagram",alt:"Illustration of saving data to a database using a queue",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Cerebellum's Infrastructure Enabling Availability with Eventual Consistency"})]}),"\n",(0,s.jsx)(n.p,{children:"This approach allowed us to prioritize availability while maintaining eventual consistency. Although there is a slight delay in data persistence, this trade-off is minor compared to the performance gains. Overall, DynamoDB\u2019s fast, flexible nature proved to be an excellent choice for handling realtime workloads, even under heavy traffic. However, as data grows over time, the cost of storing vast amounts of information in DynamoDB increases significantly. To address this, we implemented a long-term solution for managing historical data without sacrificing performance or inflating costs."}),"\n",(0,s.jsx)(n.h4,{id:"archiving-data",children:"Archiving Data"}),"\n",(0,s.jsx)(n.p,{children:"As DynamoDB tables expand, older data will likely be accessed infrequently or not at all. Leaving this data in DynamoDB can add unnecessary costs to the developer."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Let\u2019s consider a realtime communication platform, similar to Slack. To set up this example, we make the following assumptions:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"100,000 users per day"}),"\n",(0,s.jsx)(n.li,{children:"20 messages per user per day"}),"\n",(0,s.jsx)(n.li,{children:"200 bytes per message"}),"\n",(0,s.jsx)(n.li,{children:"Archive any data older than 1 year"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This means that in a 30 day month, we would have:"}),"\n",(0,s.jsx)(n.p,{children:"100,000 users/day * 20 messages * 200 bytes/message * 30 days = 12 GB per month"}),"\n",(0,s.jsx)(n.p,{children:"AWS charges $0.25 per GB per month for DynamoDB. In our example, that would result in:"}),"\n",(0,s.jsx)(n.p,{children:"$0.25 per GB-month * 12 GB = $3 per month"}),"\n",(0,s.jsxs)(n.p,{children:["If every message was left in DynamoDB indefinitely, it would result in an ",(0,s.jsx)(n.em,{children:"additional"})," $3 per month. Over 5 years, the AWS bill for storage alone would roughly cost:"]}),"\n",(0,s.jsx)(n.p,{children:"$3 + $6 + $9 + \u2026 + $180 = $5,490"}),"\n",(0,s.jsx)(n.p,{children:"If we were to archive all messages older than 1 year, we would get a max storage per year of:"}),"\n",(0,s.jsx)(n.p,{children:"12 GB * 12 months = 144 GB/month"}),"\n",(0,s.jsx)(n.p,{children:"Paying for this across 5 years, the DynamoDB bill would be:"}),"\n",(0,s.jsx)(n.p,{children:"144 GB * 60 months * $0.25 per GB-month = $2,160"}),"\n",(0,s.jsx)(n.p,{children:"If we were archiving every month, this would be ~12GB per month. The cost of storing data in an S3 bucket is $0.023 per GB per month. This means that 1 month of storage in the S3 bucket will cost:"}),"\n",(0,s.jsx)(n.p,{children:"12 GB * $0.023 per GB-month = $0.28"}),"\n",(0,s.jsx)(n.p,{children:"As a result, this storage cost for the S3 bucket over 5 years will be:"}),"\n",(0,s.jsx)(n.p,{children:"$0.28 + $0.56 + $0.84 + \u2026 + $16.80 = $512.40"}),"\n",(0,s.jsx)(n.p,{children:"That means the total spent across 5 years would be:"}),"\n",(0,s.jsx)(n.p,{children:"$2,160 + $512.40 = $2,672.40"}),"\n",(0,s.jsx)(n.p,{children:"The cost savings from archiving data would be $2,817.60."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It is important to remove data that is not being used in DynamoDB to save on costs in the long term. A cron job will trigger a Lambda function once per week. This Lambda will retrieve data from DynamoDB, save it as one JSON file to an AWS S3 bucket, and remove it from the DynamoDB table. The developer can define the age that data should be archived within the Lambda function."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/buildingCB_ArchivingData.png",className:"diagram",alt:"Illustration of a cron job archiving data from DynamoDB to S3",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Cerebellum's Infrastructure Enabling Data Archiving"})]}),"\n",(0,s.jsx)(n.h3,{id:"http-endpoint",children:"HTTP Endpoint"}),"\n",(0,s.jsxs)(n.p,{children:["Our servers could now manage both WebSocket connections and HTTP traffic, which includes messages being published from the developer's backend. However, our servers were still ",(0,s.jsx)(n.a,{href:"#challenges-with-performance",children:"tightly coupled"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We implemented a dedicated gateway for HTTP traffic using AWS API Gateway to decouple our servers and preserve performance."}),"\n",(0,s.jsx)(n.h4,{id:"implementation-of-api-gateway-and-aws-lambda",children:"Implementation of API Gateway and AWS Lambda"}),"\n",(0,s.jsx)(n.p,{children:"AWS API Gateway is the entry point for HTTP traffic, efficiently managing API requests and routing them to the appropriate backend services. It automatically scales to handle varying traffic loads, ensuring that HTTP traffic does not interfere with WebSocket connections. Additionally, API Gateway provides built-in features such as throttling and monitoring capabilities to ensure our HTTP endpoints remain performant."}),"\n",(0,s.jsx)(n.p,{children:"AWS Lambda complements the API Gateway by enabling serverless execution of code in response to HTTP GET and POST requests. This allows us to handle various types of HTTP requests without the need to manage server infrastructure. Lambda's dynamic scalability ensures that our system adapts to changing load conditions while maintaining cost efficiency."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/buildingCB_APIGateway.png",className:"diagram",alt:"Illustration showing an API gateway with a lambda function",width:"60%"}),(0,s.jsx)("figcaption",{align:"center",children:"Cerebellum's Infrastructure Including a Dedicated HTTP Gateway"})]}),"\n",(0,s.jsx)(n.p,{children:"The addition of HTTP endpoints alongside WebSocket connections expands the functionality and flexibility of our system. Key use cases for HTTP endpoints:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Retrieval:"})," Use HTTP GET requests to fetch specific data or initialize application states without needing a persistent WebSocket connection."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Posting:"})," HTTP POST requests allow stateless data submissions like form entries or file uploads when realtime communication isn't needed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration Opportunities:"})," API Gateway endpoints enable seamless integration with third-party services, allowing external systems to push notifications or updates to our platform."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"integration-with-dynamodb-and-other-services",children:"Integration with DynamoDB and Other Services"}),"\n",(0,s.jsx)(n.p,{children:"Modern applications frequently interact with diverse systems and services, often across various languages and frameworks. REST APIs make this integration straightforward, using standard HTTP methods (GET, POST) and widely supported data formats (JSON). This approach simplifies connecting our DynamoDB database and servers with other services, ensuring smoother and more efficient data interactions."}),"\n",(0,s.jsx)(n.h3,{id:"final-architecture",children:"Final Architecture"}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/Full_Infrastructure_Diagram.png",className:"diagram",alt:"Cerebellum Final Infrastructure",width:"85%"}),(0,s.jsx)("figcaption",{align:"center",children:"Cerebellum's Complete Infrastructure"})]}),"\n",(0,s.jsx)(n.h2,{id:"realtime-engineering-challenges",children:"Realtime Engineering Challenges"}),"\n",(0,s.jsx)(n.p,{children:"We had a fully formed architecture by this point, but we still needed to handle some of the common realtime application challenges."}),"\n",(0,s.jsx)(n.h3,{id:"sticky-sessions",children:"Sticky Sessions"}),"\n",(0,s.jsx)(n.p,{children:"Our WebSocket server uses Socket.io to initialize session connections, where a session is defined as a persistent WebSocket connection between the client and the server. The process of initializing a session connection is as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The client sends an HTTP GET request to the server with `transport=polling` in its query parameters."}),"\n",(0,s.jsxs)(n.li,{children:["The server responds with a session ID, an array of possible transport upgrades, and other connection-related information.","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The session ID is used by the server to identify the client and manage the connection."}),"\n",(0,s.jsx)(n.li,{children:"The list of upgrades typically includes WebSocket as the more efficient and preferred transport method."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"The client will then attempt to set up HTTP long-polling as a default first option."}),"\n",(0,s.jsxs)(n.li,{children:["The client will then attempt to upgrade the connection to a WebSocket connection by making a GET request with ",(0,s.jsx)(n.code,{children:"transport=websocket"})," in the query parameters."]}),"\n"]}),"\n",(0,s.jsxs)("figure",{className:"image-container mobile-single-image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/WebSocket_Diagram.png",className:"diagram",alt:"WebSocket Connection Handshake",width:"25%"}),(0,s.jsx)("figcaption",{align:"center",children:"WebSocket Connection Detailed Illustration"})]}),"\n",(0,s.jsx)(n.p,{children:"With only one container running, this handshake process can occur without complications. A potential problem arises when we introduce a second container and a load balancer. Due to the multiple round-trip nature of establishing a WebSocket connection, a user may be routed to a container that did not create the ID and thus will not recognize it."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/StickySession_Bad.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Failed WebSocket Connection to a Multi-Server Application without Sticky Sessions"})]}),"\n",(0,s.jsx)(n.p,{children:"To solve this problem, we implemented \u201csticky sessions\u201d by generating a cookie with the AWS load balancer and attaching it to each client request. Each subsequent request will receive a cookie in the response and include that cookie value in its request header. The load balancer will forward each request with a recognized cookie to the same server that initially handled it, bypassing the default algorithm. This ensures that the WebSocket connection is created between the associated server and the client."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/StickySession_Good.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Successful WebSocket Connection to a Multi-Server Application with Sticky Sessions Enabled"})]}),"\n",(0,s.jsx)(n.h3,{id:"connection-state-recovery",children:"Connection State Recovery"}),"\n",(0,s.jsx)(n.p,{children:"Users can momentarily disconnect from a server for several reasons\u2014some common occurrences are temporary network outages or transferring from WiFi to cellular data. During this disconnection period, the user is not able to send, receive, or display the current state."}),"\n",(0,s.jsx)(n.p,{children:"Leveraging our Redis ElastiCache, we provide connection state recovery. This enables users who unexpectedly disconnect to automatically return to the same WebSocket connection, restoring their session state and avoiding re-authentication (outlined in the next section)."}),"\n",(0,s.jsx)(n.p,{children:"In practice, when the client detects a lost connection with the server, it will try to store the last received message ID. No new data can be received during the disconnection period. Upon reconnection, the ALB will redirect the client to the same server via sticky sessions. The server will recognize the WebSocket session ID and attempt to restore the state by retrieving all missed messages from the Redis ElastiCache using Redis Streams. The messages missed between the last acknowledged message ID and the current one are fetched and delivered to the client, ensuring the state is restored."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/Connection_State_Recovery.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Connection State Recovery"})]}),"\n",(0,s.jsx)(n.p,{children:"An added benefit of this process is that upon disconnection, the client will also store any messages that have failed to send. Upon recovery, it will immediately send all buffered messages to the server."}),"\n",(0,s.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,s.jsx)(n.p,{children:"In HTTP, it's easy to handle authentication because you can send credentials like tokens with every request. With WebSockets, once the connection is established during the initial handshake, you can\u2019t modify headers or send additional authentication data. This makes it difficult to manage security throughout the session since there's no built-in way to verify the user after the connection is open. To address this for Cerebellum\u2019s WebSocket servers, we implemented token-based authentication to ensure that connections remain secure and properly authenticated throughout their duration."}),"\n",(0,s.jsx)(n.h4,{id:"token-based-authentication",children:"Token-Based Authentication"}),"\n",(0,s.jsx)(n.p,{children:"A unique API key is generated with AWS Secrets when the servers are first created using our CLI. This API key is injected into every WebSocket server as an environment variable and safely retrievable in your AWS Secrets page. The API key should then be included as an environment variable on your login server."}),"\n",(0,s.jsx)(n.p,{children:"We recommend using Cerebellum SDK to generate a short-lived token using your API key upon user authentication. This process ensures that the API key remains secure on your login servers and is not exposed to clients or external parties."}),"\n",(0,s.jsx)(n.p,{children:"Cerebellum takes the following steps to secure its servers:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Token Generation:"}),(0,s.jsx)(n.br,{}),"\n","After a user logs in, the SDK generates a short-lived token tied to your API key. This token has a set expiration time to minimize misuse."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Client Authentication:"}),(0,s.jsx)(n.br,{}),"\n","When opening a WebSocket connection, the client includes the token in the first message as a temporary credential for user authentication."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Token Verification:"}),(0,s.jsx)(n.br,{}),"\n","The WebSocket server verifies the token using the API key stored in an environment variable, without needing to query the main database, boosting performance and scalability."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handling Authentication Failures:"}),(0,s.jsx)(n.br,{}),"\n","If the token is missing or invalid, the user is denied the connection, preventing unauthorized access and helping protect against DDoS attacks."]}),"\n"]}),"\n",(0,s.jsxs)("div",{className:"flex justify-center video-container",children:[(0,s.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,s.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,s.jsx)("video",{src:"/case-study/videos/auth_bad_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:" w-full rounded-lg"})}),(0,s.jsx)("figcaption",{align:"center",children:"Failed Attempt to Connect"})]}),(0,s.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,s.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,s.jsx)("video",{src:"/case-study/videos/auth_good_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"flex-grow w-full rounded-lg"})}),(0,s.jsx)("figcaption",{align:"center",children:"Successful Attempt to Connect"})]})]}),"\n",(0,s.jsx)(n.p,{children:"By implementing this token-based authentication solution, the WebSocket servers can manage connections securely and efficiently while maintaining high performance and scalability. This approach protects the integrity of the server and ensures that only authorized users can interact with your applications."}),"\n",(0,s.jsx)(n.h3,{id:"presence",children:"Presence"}),"\n",(0,s.jsx)(n.p,{children:"In collaborative and multiplayer realtime applications, knowing who else is in the same channel or workspace is a key feature. Presence allows users to see who is active, what they\u2019re doing, and where they\u2019re working within the document."}),"\n",(0,s.jsx)(n.p,{children:"Initially, we implemented presence using a traditional pub/sub paradigm, which allowed users to broadcast their presence to others in the same channel. However, this approach had limitations. New users joining a channel could not see who was already present, leading to a lack of awareness and coordination among users. To overcome this, we needed a solution that could effectively manage and synchronize presence information across all users and servers."}),"\n",(0,s.jsx)(n.h4,{id:"utilizing-elasticache-for-presence",children:"Utilizing ElastiCache for Presence"}),"\n",(0,s.jsx)(n.p,{children:"ElastiCache with Redis OSS is an ideal solution for managing presence information in realtime applications due to its exceptional performance and low latency. Redis OSS provides an in-memory data store that supports ultra-fast data retrieval and updates, which are essential for maintaining realtime presence status. Given that Redis was already integrated into our infrastructure for the pub/sub mechanism, extending its use to handle presence data was a natural choice. Its ability to efficiently manage rapid read/write operations makes it perfect for scenarios where user presence is frequently updated. Redis\u2019 immediate consistency ensures that presence information is always current, allowing users to experience realtime changes without delay."}),"\n",(0,s.jsx)(n.p,{children:"By leveraging Redis as our single source for presence information, we can synchronize presence data across all servers. When a user joins, leaves, or updates their presence information, the changes are immediately reflected in Redis, which is accessible by all servers in the cluster. This update is then broadcasted via the pub/sub system, notifying all users subscribed to that presence channel, and providing a consistent source of presence information for all servers."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/Presence.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"Realtime User Presence"})]}),"\n",(0,s.jsx)(n.h4,{id:"how-to-handle-disconnections",children:"How to Handle Disconnections"}),"\n",(0,s.jsx)(n.p,{children:"A key challenge in building presence functionality is managing user disconnections. When a client disconnects, the server must notify other users in the presence channels, as the client can no longer update its status. This prevents stale data in the Redis cache and ensures presence information stays current."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/Presence_Disconnection_Bad.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"User Loses Connection but Presence is not Updated"})]}),"\n",(0,s.jsx)(n.p,{children:"To address this, we assign a unique ID to each client connected to a server. This ID is stored in Redis along with a list of all that user\u2019s presence channels. When a disconnection event is detected, the server automatically iterates through the list of that user\u2019s presence channels and notifies the corresponding presence channel that the user has left. Lastly, the server removes the user\u2019s presence information from the Redis cache to ensure it always has the most up-to-date information for everyone who joins."}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("video",{src:"/case-study/videos/Presence_Disconnection.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,s.jsx)("figcaption",{align:"center",children:"User Loses Connection and Presence is Successfully Updated"})]}),"\n",(0,s.jsx)(n.h2,{id:"load-testing",children:"Load Testing"}),"\n",(0,s.jsx)(n.p,{children:"Our primary load-testing strategy was focused on determining how many concurrent users a server could handle. To test this, we spun up one Cerebellum WebSocket server on an AWS Fargate container and ran an Artillery test on our cloud infrastructure."}),"\n",(0,s.jsxs)(n.p,{children:["One approach when auto-scaling in ECS is to scale horizontally when the CPU or memory reaches a certain percentage. ",(0,s.jsx)(n.a,{href:"https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-configure-scaling-plan.html#:~:text=For%20example%2C%20the%20scaling%20plan,a%20different%20metric%2C%20or%20both.",children:"AWS recommends"})," scaling out at 40% to optimize for performance, 70% for cost, or 50% for a balanced optimization. Per this recommendation, we chose 50% as the default for high performance and reasonable cost efficiency."]}),"\n",(0,s.jsx)(n.h4,{id:"terminology",children:"Terminology"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Max:"})," Maximum computing resources allocated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Baseline:"})," Percent utilization on the Fargate container immediately before the test."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Peak:"})," Percent utilization on the Fargate container at peak usage during the test."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Difference:"})," Difference between baseline and peak."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Idle user:"})," A user that connects to the server via WebSockets and does nothing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Active users:"})," A user that connects to the server via WebSockets and posts messages to a channel"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"1-limit-of-concurrent-idle-users",children:"1) Limit of Concurrent Idle Users"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Created 1,000 idle users over 120 seconds"}),"\n",(0,s.jsx)(n.li,{children:"Recorded Peak CPU and Memory usage"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Results:"}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/load_test_idle_user.png",className:"diagram",alt:"Load testing diagram for idle users",width:"70%"}),(0,s.jsx)("figcaption",{align:"center",children:"Load Testing Results for Idle Users"})]}),"\n",(0,s.jsx)(n.h4,{id:"2-limit-of-concurrent-active-users",children:"2) Limit of Concurrent Active Users"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Created 1,000 active users over 120 seconds"}),"\n",(0,s.jsx)(n.li,{children:"Recorded Peak CPU and Memory usage"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Results:"}),"\n",(0,s.jsxs)("figure",{className:"image-container",children:[(0,s.jsx)("img",{src:"/case-study/photos/load_test_active.png",className:"diagram",alt:"Load testing for active users",width:"70%"}),(0,s.jsx)("figcaption",{align:"center",children:"Load Testing Results for Active Users"})]}),"\n",(0,s.jsx)(n.h4,{id:"calculations",children:"Calculations"}),"\n",(0,s.jsx)(n.p,{children:"The limiting factor causing a container to scale is the CPU usage recorded in the idle users test. Assuming a linear relationship, we extrapolated the total number of users that trigger auto-scaling."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Baseline (%) + ( Difference (%) * Scaling Factor ) = Scaling Limit (%)"}),"\n",(0,s.jsx)(n.p,{children:"0.8% + (11.6% * Scaling Factor) = 50% => Scaling Factor \u2248 4.24"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Therefore, if we multiply the number of users at peak by the scaling factor, we can estimate how many concurrent users the container can handle before needing to scale."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"1,000 * 4.24 = 4,240 users"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"At 0.25 vCPU and 0.5 GB memory, Cerebellum\u2019s WebSocket servers will comfortably accommodate 4,240 users before auto-scaling."}),"\n",(0,s.jsx)(n.p,{children:"*These tests are not optimized to test the maximum load that could be placed on our Redis cache. Testing the Redis more extensively would include subscribing and adding presence for multiple users to one channel and testing the strain of the fanning out data and presence across that channel. This is a consideration for future load testing."}),"\n",(0,s.jsx)(n.h2,{id:"in-the-pipeline",children:"In the Pipeline..."}),"\n",(0,s.jsx)(n.h4,{id:"archived-message-retrieval",children:"Archived Message Retrieval"}),"\n",(0,s.jsx)(n.p,{children:"We\u2019ve implemented automated message archiving to reduce costs by moving older data from DynamoDB to S3. While retrieval is supported, our WebSocket server doesn\u2019t yet automate this. Developers currently handle it manually."}),"\n",(0,s.jsx)(n.h4,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,s.jsx)(n.p,{children:"In building our WebSocket infrastructure with an Application Load Balancer (ALB), we focused on scalability and ease of integration. The ALB effectively manages WebSocket connections, ensuring high availability and fault tolerance, though it lacks built-in rate-limiting capabilities\u2014an important consideration for protecting servers and ensuring fair usage."}),"\n",(0,s.jsx)(n.p,{children:"Our current setup doesn\u2019t impose rate limits on incoming WebSocket connections, leaving this aspect to be managed by external solutions or client-side throttling. While API Gateway and AWS WAF offer rate-limiting features, they introduce performance trade-offs and a need for careful cost-benefit analysis due to the complexity of configuring these services for WebSocket workloads."}),"\n",(0,s.jsx)(n.h4,{id:"elasticache-load-testing-and-failover",children:"ElastiCache: Load Testing and Failover"}),"\n",(0,s.jsx)(n.p,{children:"We have not yet tested the physical limit of our ElastiCache. Load testing should be performed by testing channel user limit and presence to determine this limit."}),"\n",(0,s.jsx)(n.p,{children:"Additionally, this single ElastiCache represents a single point of failure. Our infrastructure would benefit from designating a fallback ElastiCache in case our active ElastiCache crashes."}),"\n",(0,s.jsx)(n.h4,{id:"cloud-agnostic-offering",children:"Cloud-Agnostic Offering"}),"\n",(0,s.jsx)(n.p,{children:"AWS is our preferred cloud provider due to its extensive services and market dominance. However, we understand that other platforms like Azure and Google Cloud also have strong offerings, and some developers may prefer to consolidate resources with a different provider. While our current focus is on AWS, we acknowledge the potential benefits of a cloud-agnostic approach."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var s=i(6540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);