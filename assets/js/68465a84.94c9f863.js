"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[249],{4133:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=n(4848),s=n(8453);const a={title:"Case Study",description:"Cerebellum Case Study",toc_min_heading_level:2,toc_max_heading_level:3,className:"test"},r="Case Study",o={type:"mdx",permalink:"/case-study",source:"@site/src/pages/case-study.md",title:"Case Study",description:"Cerebellum Case Study",frontMatter:{title:"Case Study",description:"Cerebellum Case Study",toc_min_heading_level:2,toc_max_heading_level:3,className:"test"},unlisted:!1},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Background: Realtime",id:"background-realtime",level:2},{value:"Realtime Categories",id:"realtime-categories",level:3},{value:"Hard Realtime",id:"hard-realtime",level:4},{value:"Soft Realtime",id:"soft-realtime",level:4},{value:"Realtime Techniques &amp; Technologies",id:"realtime-techniques--technologies",level:3},{value:"WebSockets",id:"websockets",level:4},{value:"WebTransport",id:"webtransport",level:4},{value:"Conclusion",id:"conclusion",level:4},{value:"Scaling WebSocket Applications is Not Trivial",id:"scaling-websocket-applications-is-not-trivial",level:3},{value:"Challenges with State",id:"challenges-with-state",level:4},{value:"Challenges with Performance",id:"challenges-with-performance",level:4},{value:"Dedicated Realtime Infrastructure",id:"dedicated-realtime-infrastructure",level:4},{value:"Finding the Right Fit for Your Application",id:"finding-the-right-fit-for-your-application",level:2},{value:"DIY Solutions",id:"diy-solutions",level:3},{value:"Enterprise Solutions",id:"enterprise-solutions",level:3},{value:"Cerebellum",id:"cerebellum",level:3},{value:"Comparing Solutions",id:"comparing-solutions",level:3},{value:"Building Cerebellum\u2019s Infrastructure",id:"building-cerebellums-infrastructure",level:2},{value:"Establishing a Connection on a Single Server",id:"establishing-a-connection-on-a-single-server",level:3},{value:"Scaling Complexities with Multiple Servers",id:"scaling-complexities-with-multiple-servers",level:3},{value:"Scalable Servers",id:"scalable-servers",level:4},{value:"Pub/Sub",id:"pubsub",level:4},{value:"Redis Streams as Our Pub/Sub System",id:"redis-streams-as-our-pubsub-system",level:4},{value:"Balancing the Load Distribution",id:"balancing-the-load-distribution",level:4},{value:"Persisting Data in a Realtime Application",id:"persisting-data-in-a-realtime-application",level:3},{value:"Choosing the Right Database for Realtime Applications",id:"choosing-the-right-database-for-realtime-applications",level:4},{value:"Availability vs. Consistency",id:"availability-vs-consistency",level:4},{value:"Archiving Data",id:"archiving-data",level:4},{value:"HTTP Endpoint",id:"http-endpoint",level:3},{value:"Implementation of API Gateway and AWS Lambda",id:"implementation-of-api-gateway-and-aws-lambda",level:4},{value:"Integration with DynamoDB and Other Services",id:"integration-with-dynamodb-and-other-services",level:4},{value:"Realtime Engineering Challenges",id:"realtime-engineering-challenges",level:2},{value:"Sticky Sessions",id:"sticky-sessions",level:3},{value:"Connection State Recovery",id:"connection-state-recovery",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Token-Based Authentication",id:"token-based-authentication",level:4},{value:"Presence",id:"presence",level:3},{value:"Utilizing ElastiCache for Presence",id:"utilizing-elasticache-for-presence",level:4},{value:"How to Handle Disconnections",id:"how-to-handle-disconnections",level:4},{value:"Load Testing",id:"load-testing",level:2},{value:"Terminology",id:"terminology",level:4},{value:"1) Limit of Concurrent Idle Users",id:"1-limit-of-concurrent-idle-users",level:4},{value:"2) Limit of Concurrent Active Users",id:"2-limit-of-concurrent-active-users",level:4},{value:"Calculations",id:"calculations",level:4},{value:"Conclusion",id:"conclusion-1",level:4},{value:"In the Pipeline...",id:"in-the-pipeline",level:2},{value:"Archived Message Retrieval",id:"archived-message-retrieval",level:4},{value:"Rate Limiting",id:"rate-limiting",level:4},{value:"ElastiCache: Load Testing and Failover",id:"elasticache-load-testing-and-failover",level:4},{value:"Cloud-Agnostic Offering",id:"cloud-agnostic-offering",level:4}];function d(e){const i={a:"a",blockquote:"blockquote",br:"br",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"case-study",children:"Case Study"}),"\n",(0,t.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(i.p,{children:"Cerebellum is a drop-in infrastructure and library for scalable realtime applications. Whether starting from scratch or integrating an existing application, Cerebellum enables developers to move from development to fully scalable deployment in just a few simple steps."}),"\n",(0,t.jsx)(i.p,{children:"Alongside our ready-made infrastructure, we offer a Software Development Kit (SDK) and a production-ready WebSocket server, empowering developers to deploy quickly and efficiently without the hassle of managing cloud platforms or connections."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/Full_Infrastructure_Diagram.png",className:"diagram",alt:"Cerebellum Infrastructure",width:"85%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 1.1: Cerebellum's Infrastructure"})]}),"\n",(0,t.jsx)(i.h2,{id:"background-realtime",children:"Background: Realtime"}),"\n",(0,t.jsxs)(i.p,{children:["Let\u2019s take a step back to understand the concept of realtime. Realtime is the ",(0,t.jsx)(i.em,{children:"instantaneous"})," exchange of data. Instantaneous in computing terms means to be ",(0,t.jsx)(i.em,{children:"perceived"})," as instantaneous. This metric can vary depending on the constraints of the application, but instantaneous is commonly considered to be ",(0,t.jsx)(i.a,{href:"https://www.pubnub.com/blog/how-fast-is-realtime-human-perception-and-technology/",children:"below 100-millisecond latency"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Realtime applications are divided into two main categories, each with distinct time constraints or \u201cdeadlines\u201d that must be met to ensure a proper response."}),"\n",(0,t.jsx)(i.h3,{id:"realtime-categories",children:"Realtime Categories"}),"\n",(0,t.jsx)(i.h4,{id:"hard-realtime",children:"Hard Realtime"}),"\n",(0,t.jsxs)(i.p,{children:["Hard realtime applications demand absolute performance where timing is crucial, and deadlines ",(0,t.jsx)(i.strong,{children:"must"})," be met without exception. Missing a deadline in a hard realtime system can lead to total system failure and catastrophic consequences, often involving safety hazards or physical damage. The importance of a task is directly tied to meeting its deadline; missing it can render the task's value null. Examples of such systems include emergency medical devices, industrial automation systems, and flight control systems."]}),"\n",(0,t.jsx)("figure",{className:"image-container ",children:(0,t.jsxs)(i.p,{children:[(0,t.jsx)("img",{src:"/case-study/photos/Hard_Realtime.png",className:"diagram",alt:"Hard Realtime",width:"30%"}),"  <\n",(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.1: Hard Realtime"})]})}),"\n",(0,t.jsx)(i.h4,{id:"soft-realtime",children:"Soft Realtime"}),"\n",(0,t.jsx)(i.p,{children:"In soft realtime applications, missing a deadline results in a degradation of service quality, which can negatively impact user experience and be quite frustrating. However, it does not lead to system failure or significant harm. The value of a task is somewhat correlated with meeting the deadline\u2014if missed, the value decreases but does not become. Examples of soft realtime systems include messaging apps, online multiplayer games, and collaborative editors."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/Soft_Realtime.png",className:"diagram",alt:"Soft Realtime",width:"30%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.2: Soft Realtime"})]}),"\n",(0,t.jsxs)(i.p,{children:["Identifying which category your application falls into helps set appropriate expectations and informs design decisions, which can differ significantly. ",(0,t.jsx)(i.em,{children:"Cerebellum is designed specifically for soft realtime applications."})]}),"\n",(0,t.jsx)(i.p,{children:"Building on this foundation, we can examine key techniques and technologies that facilitate realtime communication between client applications and servers."}),"\n",(0,t.jsx)(i.h3,{id:"realtime-techniques--technologies",children:"Realtime Techniques & Technologies"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Short polling"})," involves sending HTTP requests at intervals to check for new data. While simple to implement, it can create unnecessary network traffic and server load when no new updates are available."]}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/ShortPolling_Diagram.png",className:"diagram",alt:"Short Polling",width:"30%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.3: Short Polling"})]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Long polling"})," improves on this by keeping the connection open until new data arrives, reducing redundant requests. However, it still requires the client to initiate each new request, which can lead to occasional synchronization issues."]}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/LongPolling_Diagram.png",className:"diagram",alt:"Long Polling",width:"30%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.4: Long Polling"})]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Server-Sent Events"})," (SSEs) further optimize this process by maintaining an open connection where the server continuously pushes updates to the client as they become available, eliminating the need for repeated requests and minimizing latency."]}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/SSE_Diagram.png",className:"diagram",alt:"Server-Sent Events",width:"30%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.5: Server-Sent Events"})]}),"\n",(0,t.jsx)(i.p,{children:"While SSEs are efficient for one-way updates, they do not allow the client to send data back to the server in the same connection. This is where WebSockets excel."}),"\n",(0,t.jsx)(i.h4,{id:"websockets",children:"WebSockets"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.strong,{children:"WebSocket"})," protocol offers full-duplex communication over a single long-lived Transmission Control Protocol (TCP) connection. After an initial \u201chandshake\u201d to establish the connection, a dedicated low-latency channel is created, allowing for ",(0,t.jsx)(i.em,{children:"instantaneous"})," data exchange in ",(0,t.jsx)(i.em,{children:"both"})," directions."]}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/WebSocket_Diagram1.png",className:"diagram",alt:"WebSocket Diagram",width:"30%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.6: WebSocket Connection"})]}),"\n",(0,t.jsx)(i.h4,{id:"webtransport",children:"WebTransport"}),"\n",(0,t.jsx)(i.p,{children:"The WebTransport API is an emerging technology that offers a promising alternative to WebSockets. WebTransport utilizes multiplexed streams and datagrams over HTTP/3 and the QUIC protocol. This setup allows multiple data streams to function independently within the same connection, reducing latency and avoiding head-of-line blocking\u2014a problem in single-stream systems like WebSockets where delays in one packet can affect all subsequent packets. WebTransport\u2019s capabilities make it particularly effective for handling numerous simultaneous realtime data exchanges, such as video streaming or complex online games."}),"\n",(0,t.jsx)(i.p,{children:"However, WebTransport is still in development and lacks support across all browsers. In contrast, WebSockets were established in the early 2010s and are supported by a robust, active community."}),"\n",(0,t.jsx)(i.h4,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(i.p,{children:"We determined that WebSockets are the most suitable for our focus and application. Although each option offers unique advantages, WebSockets excel in providing instantaneous bi-directional communication and are well-established with broad browser support."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/CommunicationComparisonChart.png",className:"diagram",alt:"Realtime Comparison Chart",width:"60%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.7: Realtime Techniques & Technologies"})]}),"\n",(0,t.jsx)(i.p,{children:"However, WebSockets come with distinct complexities, particularly when it comes to scaling."}),"\n",(0,t.jsx)(i.h3,{id:"scaling-websocket-applications-is-not-trivial",children:"Scaling WebSocket Applications is Not Trivial"}),"\n",(0,t.jsxs)(i.p,{children:["Scaling ",(0,t.jsx)(i.em,{children:"any"})," type of application requires vertical scaling, horizontal scaling, or some combination thereof. Vertical scaling involves adding more power to a single server, while horizontal scaling spreads the load across multiple servers."]}),"\n",(0,t.jsxs)("div",{className:"flex justify-center video-container",children:[(0,t.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,t.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,t.jsx)("video",{src:"/case-study/videos/vertical_scale_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:" w-full rounded-lg"})}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.8: Vertical Scaling"})]}),(0,t.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,t.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,t.jsx)("video",{src:"/case-study/videos/horizontal_scaling_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"flex-grow w-full rounded-lg"})}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.9: Horizontal Scaling"})]})]}),"\n",(0,t.jsx)(i.p,{children:"Scaling realtime WebSocket applications comes with an additional set of unique challenges. It\u2019s helpful to use HTTP-based applications as a benchmark to understand these challenges."}),"\n",(0,t.jsx)(i.h4,{id:"challenges-with-state",children:"Challenges with State"}),"\n",(0,t.jsx)(i.p,{children:"One of the main differences between HTTP-based applications and WebSocket applications relates to state. In an HTTP interaction, the client initiates a request to the server, which processes the request and sends back a response, after which the connection is terminated. This type of communication is considered stateless because each request is independent and doesn\u2019t rely on information from previous interactions. Because HTTP-based applications are stateless, any server can handle any request, making horizontal scaling straightforward."}),"\n",(0,t.jsx)(i.p,{children:"In contrast, WebSocket applications keep a persistent connection, meaning that the server must maintain state information for each connection. This complicates scaling, as multiple servers must share and synchronize this state to maintain data consistency across the application. For instance, if two users are connected to different servers, additional infrastructure is needed to ensure they can still communicate seamlessly."}),"\n",(0,t.jsxs)("div",{className:"flex justify-center video-container",children:[(0,t.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,t.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,t.jsx)("video",{src:"/case-study/videos/client_server_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:" w-full"})}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.8: Vertical Scaling"})]}),(0,t.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,t.jsx)("video",{src:"/case-study/videos/client_server_msg_lost_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"flex-grow w-full rounded-lg"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 2.9: Horizontal Scaling"})]})]}),"\n",(0,t.jsx)(i.h4,{id:"challenges-with-performance",children:"Challenges with Performance"}),"\n",(0,t.jsx)(i.p,{children:"Servers managing WebSocket connections face a heavier workload than those dealing with standard HTTP requests. Unlike HTTP, where connections are transient, WebSockets require the server to maintain ongoing, persistent connections while simultaneously handling new connection requests. This dual responsibility significantly increases resource consumption, particularly for memory and CPU. This can lead to performance degradation and a poor user experience if not managed properly."}),"\n",(0,t.jsx)(i.p,{children:"A common approach might be to add realtime capabilities to an existing server that also handles non-realtime tasks. This creates a \u201ctightly coupled\u201d system, where both realtime and non-realtime components share the same infrastructure and resources. While this setup offers simplicity, especially for smaller applications, it introduces several risks as the application scales:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Performance Bottlenecks"}),": Shared resources can slow down both the realtime and non-realtime components."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Different Scaling Needs"}),": Realtime and non-realtime components may require scaling at different rates, which is difficult to manage in a coupled system."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Single Point of Failure"}),": A failure in the server can impact both components, increasing the likelihood of downtime."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Decoupling the realtime component from the non-realtime application is essential to mitigating these risks. By separating these systems, each can scale independently, allowing the realtime component to handle increased traffic without affecting the non-realtime part, and vice versa. This decoupling ensures that both performance and reliability are optimized, meeting the unique demands of scaling WebSocket applications."}),"\n",(0,t.jsx)(i.h4,{id:"dedicated-realtime-infrastructure",children:"Dedicated Realtime Infrastructure"}),"\n",(0,t.jsx)(i.p,{children:"Scaling WebSocket applications effectively requires specialized infrastructure. However, sourcing, configuring, and maintaining such infrastructure can be a significant burden for developers, diverting attention away from core product development. A dedicated infrastructure for realtime communication not only alleviates these challenges but also ensures that both performance and state management are optimized for the unique demands of WebSocket applications."}),"\n",(0,t.jsx)(i.h2,{id:"finding-the-right-fit-for-your-application",children:"Finding the Right Fit for Your Application"}),"\n",(0,t.jsx)(i.p,{children:"There are several different approaches when considering implementing your realtime application. It\u2019s helpful to ground this topic in terms of effort, control, and flexibility as a relative measurement to understand the difference between the approaches we will outline."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Effort:"})," Labor required to set up and maintain your application."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Control:"})," The degree to which you own your data and infrastructure."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Flexibility:"})," The degree to which you can customize your application\u2019s logic and infrastructure."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The main solutions we\u2019ll explore in this section are do-it-yourself (DIY), enterprise, and Cerebellum. Each solution has its own level of effort, control, and flexibility."}),"\n",(0,t.jsx)(i.h3,{id:"diy-solutions",children:"DIY Solutions"}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/GenericUserLogo.png",className:"diagram",alt:"DIY Logo",width:"10%"})}),"\n",(0,t.jsx)(i.p,{children:"Developer teams whose core product is realtime might want full control over their data, infrastructure, and logical abstractions. In this case, they might use a library like Node.js\u2019 WebSocket library or Socket.io. They could also implement their own WebSocket API. Given realtime is the developer team\u2019s main product offering in this scenario, dedicating significant time to this effort becomes justifiable."}),"\n",(0,t.jsx)(i.p,{children:"Implementing a DIY solution requires more effort than any other option. On the other hand, DIY allows for a high level of control because the developer has full control over their data and infrastructure. They can make their own design decisions and store their data however they see fit. Finally, DIY comes with the benefit of being completely customizable, and therefore has the highest level of flexibility."}),"\n",(0,t.jsx)(i.h3,{id:"enterprise-solutions",children:"Enterprise Solutions"}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/AblyLogo.png",className:"diagram",alt:"Ably Logo",width:"10%"})}),"\n",(0,t.jsx)(i.p,{children:"The story changes if the developer team\u2019s core product is not realtime. If a developer team doesn\u2019t specialize in realtime and wants to add a realtime component to an existing product, they probably would not want to start from scratch. The time spent building a DIY solution would be better invested in working on their core product offering."}),"\n",(0,t.jsx)(i.p,{children:"They may look into a third-party solution like Ably or PartyKit. These options both handle infrastructure and provide easy-to-use abstractions for common realtime tasks. The downside is that there is still some legwork, such as integrating a database for handling data persistence. This option also forfeits control of infrastructure and data to the third-party service."}),"\n",(0,t.jsx)(i.p,{children:"Enterprise solutions require the lowest effort of choices we outline here. They allow you to hit the ground running with a realtime application in the shortest time. This does come with a trade-off. Enterprise solutions provide the lowest amount of control and flexibility. Developers forfeit direct management of their data to the enterprise provider. Also, enterprise solutions aren\u2019t extendable. The developer is locked into whatever design decisions the enterprise solution implements. This provides very little flexibility."}),"\n",(0,t.jsx)(i.h3,{id:"cerebellum",children:"Cerebellum"}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/img/logo.png",className:"diagram",alt:"Cerebellum Logo",width:"10%"})}),"\n",(0,t.jsx)(i.p,{children:"The options we\u2019ve looked at so far sacrifice high control and flexibility in exchange for low effort. Neither of these solutions provides both low effort and high flexibility. We positioned Cerebellum to fit this gap in the market."}),"\n",(0,t.jsx)(i.p,{children:"We built Cerebellum for small to medium-sized development teams who want a realtime solution that handles infrastructure with strong support for data persistence, long-term storage, and an easy-to-use interface."}),"\n",(0,t.jsx)(i.h3,{id:"comparing-solutions",children:"Comparing Solutions"}),"\n",(0,t.jsx)(i.p,{children:"We chose eight comparison points for Ably, PartyKit, Cerebellum, and DIY:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Persistence:"})," Out-of-the-box ability to store messages or data across sessions, ensuring that information is not lost."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"User Presence:"})," Tracking and reporting the status and user details in realtime applications."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Open Source:"})," Indicates whether the software\u2019s source code is available for anyone to inspect, modify, and enhance."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Ownership:"})," Defines who owns and controls the data generated and stored by the application."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Exactly Once Delivery:"})," Ensures that messages are delivered exactly once, which is critical for avoiding duplicates in certain applications."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Auto Scaling:"})," Ability to automatically scale resources up or down based on application demand."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Multi-Language Support:"})," Support for multiple programming languages, enabling developers to work in their preferred language."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Cost:"})," The relative cost of using the service, assessed in terms of operational expenses for a typical use case."]}),"\n"]}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/Product_Comparison_Chart.png",className:"diagram",alt:"Realtime Solution Comparison Chart",width:"60%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 3.1: Comparing Solutions"})]}),"\n",(0,t.jsx)(i.p,{children:"*Ably stores all messages for two minutes out of the box, with an option to increase to 72 hours in their premium package. Longer data persistence requires a third-party solution."}),"\n",(0,t.jsx)(i.p,{children:"Equipped with this technical background and a deeper insight into the realtime market, we can now explore the specifics of Cerebellum and the design choices we implemented."}),"\n",(0,t.jsx)(i.h2,{id:"building-cerebellums-infrastructure",children:"Building Cerebellum\u2019s Infrastructure"}),"\n",(0,t.jsx)(i.p,{children:"We built Cerebellum to meet the demands of realtime applications with an ever-increasing user base. This required provisioning servers for horizontal scaling, ensuring our architecture could maintain performance and reliability as the number of WebSocket connections increased."}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.a,{href:"https://www.ibm.com/topics/cap-theorem",children:"CAP theorem"})," highlights a fundamental trade-off in distributed systems: they can prioritize either availability or consistency, but not both simultaneously. Availability ensures that data requests always receive a response, even if parts of the system fail. Consistency guarantees that all clients see the same data, which can sometimes come at the expense of longer load times."]}),"\n",(0,t.jsx)(i.p,{children:"Since Cerebellum is designed for soft realtime applications, we prioritize availability over consistency."}),"\n",(0,t.jsxs)(i.p,{children:["Our architecture was built with this prioritization in mind. We chose AWS as our preferred platform to host the infrastructure, due to its extensive service offerings and ",(0,t.jsx)(i.a,{href:"https://www.statista.com/chart/18819/worldwide-market-share-of-leading-cloud-infrastructure-service-providers/",children:"dominant market share"})," among cloud providers."]}),"\n",(0,t.jsx)(i.p,{children:"Given Cerebellum's broad applicability to realtime applications, our architecture must support a wide range of realtime application needs, from chat applications to collaborative editing to gaming platforms. This versatility demands a flexible infrastructure. In the following sections, we will explore the specific components and design choices that form Cerebellum\u2019s architecture, illustrating how each element contributes to performance, reliability, and scalability."}),"\n",(0,t.jsx)(i.h3,{id:"establishing-a-connection-on-a-single-server",children:"Establishing a Connection on a Single Server"}),"\n",(0,t.jsx)(i.p,{children:"We initially built our infrastructure with a single WebSocket server, allowing us to simplify development and focus on creating a stable realtime communication library."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/buildingCB_OneServer.png",className:"diagram",alt:"Architecture Diagram with API Gateway",width:"35%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 4.1: Single-Server Connections"})]}),"\n",(0,t.jsx)(i.p,{children:"However, as traffic on this one server increases, computing resources will eventually reach their upper limit. This will increase the latency of the server\u2019s response time and cause the server to crash if more resources are not allocated. Moreover, relying on a single server introduces a single point of failure."}),"\n",(0,t.jsx)(i.h3,{id:"scaling-complexities-with-multiple-servers",children:"Scaling Complexities with Multiple Servers"}),"\n",(0,t.jsx)(i.p,{children:"As user traffic and server load grow, the infrastructure must adapt in real time. Making our infrastructure horizontally scalable allowed for dynamic scaling but also introduced complexities and trade-offs."}),"\n",(0,t.jsx)(i.h4,{id:"scalable-servers",children:"Scalable Servers"}),"\n",(0,t.jsx)(i.p,{children:"The first step to this was to replace our single application server with a dynamically scalable one to build a horizontally scalable architecture."}),"\n",(0,t.jsx)(i.p,{children:"Our solution was to use AWS Elastic Container Service (ECS) with AWS Fargate. Containers are lightweight, portable units that package an application and its dependencies. These containers are created from images, which are snapshots of the application environment, including the code, libraries, and system settings."}),"\n",(0,t.jsx)(i.p,{children:"ECS is an orchestrator\u2014it manages the number of containers running at any given time. ECS monitors server load and decides when to scale up or down accordingly. Fargate is a compute engine that eliminates the need to provision and manage servers by creating serverless containers on demand. It allows us to define a Docker or Elastic Container Registry image (our WebSocket server by default) and creates a container with a pre-specified operating system."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/buildingCB_ECSCluster.png",className:"diagram",alt:"Architecture Diagram with API Gateway",width:"45%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 4.2: ECS Connections"})]}),"\n",(0,t.jsx)(i.p,{children:"While our infrastructure could now automatically scale based on user load, users connected to different servers couldn't communicate with each other. Each server maintained its own isolated state and connection data. As a result, a user connected to one server wouldn't be able to reach a user connected to a different server. This isolation severely impacted the realtime communication functionality of our application, which relied on consistent message delivery across all clients regardless of their server connection."}),"\n",(0,t.jsx)(i.p,{children:"We needed a way for data to allow data flow and consistency between our servers. We implemented a pub/sub to facilitate this cross-server communication."}),"\n",(0,t.jsx)(i.h4,{id:"pubsub",children:"Pub/Sub"}),"\n",(0,t.jsx)(i.p,{children:"Publish/Subscribe (Pub/Sub) is a messaging pattern used in distributed systems to facilitate communication between different components. For context around this discussion, we\u2019ll define some key terms related to the pub/sub model:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Channels"}),' (also known as "rooms" or "topics") are communication hubs where messages are exchanged between publishers and subscribers.']}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Subscribers"})," are users or systems that receive notifications when a message is sent to a channel they follow."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Publishers"})," are users or systems that send messages to channels."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"In the pub/sub model, publishers and subscribers are decoupled. Publishers can send messages to channels without needing to know who the subscribers are, and subscribers receive messages without knowing who the publishers are. This decoupling enables scalable and flexible architectures, allowing components to be added, removed, or modified independently."}),"\n",(0,t.jsx)(i.p,{children:"By implementing a pub/sub system, when a user sends a message to a server, it is received by the pub/sub system and forwarded to all subscribers of that channel, regardless of which server they are connected to. This ensures that all users receive the same information in real time, overcoming the challenges of server isolation and ensuring consistent message delivery across multiple servers."}),"\n",(0,t.jsx)("figure",{className:"flex justify-center",children:(0,t.jsx)("video",{src:"/case-study/videos/ChannelsPubSub.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "})}),"\n",(0,t.jsx)(i.h4,{id:"redis-streams-as-our-pubsub-system",children:"Redis Streams as Our Pub/Sub System"}),"\n",(0,t.jsx)(i.p,{children:"For our pub/sub system, we leveraged the capabilities of AWS ElastiCache for Redis, specifically utilizing Redis Streams. While Redis is often known for its key/value cache functionality, it also offers powerful features for building robust pub/sub systems."}),"\n",(0,t.jsx)(i.p,{children:"Redis Streams provides an append-only log data structure that supports more complex pub/sub scenarios. Key advantages include:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Persistence:"})," Messages in Redis Streams can be persisted, enabling replay and recovery, which is crucial for maintaining the connection state in realtime applications (a key requirement which we will discuss in detail in the ",(0,t.jsx)(i.a,{href:"#realtime-engineering-challenges",children:"Realtime Engineering Challenges"})," section)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Backpressure Handling:"})," Streams allow servers to regulate the rate of message consumption, preventing overload by controlling the flow of incoming messages."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"We selected Redis Streams due to the high availability and low latency provided by AWS ElastiCache."}),"\n",(0,t.jsx)(i.p,{children:"In our Redis Streams implementation, the message flow differs slightly from traditional pub/sub systems. When a message is published, it is appended to a Redis Stream associated with a specific channel or topic. Each message is stored with a unique ID, ensuring persistence. Servers act as consumers, reading from these streams at their own pace and capacity. After retrieving messages, servers forward them to clients subscribed to the respective channels. This retains the core principles of a traditional pub/sub while also enabling data persistence."}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("video",{src:"/case-study/videos/Redis_Streams.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "})}),"\n",(0,t.jsx)(i.p,{children:"With our Redis Streams-based pub/sub system in place, we had to establish a single, secure public entry point while balancing load across multiple servers."}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/buildingCB_Elasticache.png",className:"diagram",alt:"Architecture Diagram with API Gateway"})}),"\n",(0,t.jsx)(i.h4,{id:"balancing-the-load-distribution",children:"Balancing the Load Distribution"}),"\n",(0,t.jsx)(i.p,{children:"Realtime applications require high availability and fault tolerance to ensure seamless user experiences, even during partial system failures. We use an Application Load Balancer (ALB) to distribute incoming traffic across multiple servers to achieve this. The ALB prevents any server from becoming overwhelmed and enhances overall performance and reliability."}),"\n",(0,t.jsx)(i.p,{children:"We considered a few options for routing traffic:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Round Robin:"})," Distributes each request sequentially to the next server. This method works well when traffic is uniform and servers have similar processing power."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Least Outstanding Requests:"})," Routes traffic to the server with the fewest active connections. This is ideal when request processing times vary and servers have different capabilities."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Since our infrastructure scales by duplicating containers with identical processing power, we initially considered Round Robin. However, we cannot anticipate uniform traffic in the realtime applications. Additionally, when new servers are spun up, we need to route traffic more heavily to them to utilize their increased capacity. Therefore, Least Outstanding Requests was our top choice to ensure a more balanced load across servers."}),"\n",(0,t.jsx)(i.p,{children:"In addition to balancing load, the ALB provides other key benefits:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Health Checks"}),": The ALB tracks which servers are healthy/unhealthy and re-routes traffic accordingly."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"SSL/TLS Encryptions"}),": The ALB enforces encryption to protect data between client and server."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"By handling these tasks, the ALB solved a crucial part of our infrastructure needs, ensuring the stability and security of our realtime applications while managing server load."}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/buildingCB_LoadBalancer.png",className:"diagram",alt:"Architecture Diagram with API Gateway"})}),"\n",(0,t.jsx)(i.h3,{id:"persisting-data-in-a-realtime-application",children:"Persisting Data in a Realtime Application"}),"\n",(0,t.jsx)(i.p,{children:"At this stage, our architecture successfully provided realtime scaling and communication, but we recognized a major limitation in the need for historical data access. This is vital for various realtime applications, including:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Collaborative Editors:"})," Applications like Google Docs need to maintain past revisions."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Video Conferencing:"})," Services like Zoom provide video recording features."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Communication Apps:"})," Platforms like Slack require persistent message history."]}),"\n"]}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("video",{src:"/case-study/videos/Connection_State_Recovery.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "})}),"\n",(0,t.jsx)(i.h4,{id:"choosing-the-right-database-for-realtime-applications",children:"Choosing the Right Database for Realtime Applications"}),"\n",(0,t.jsx)(i.p,{children:"Considerations when selecting a database for realtime applications were scalability, low latency, high throughput, and flexibility\u2014specifically regarding dynamic data structures. Because these were our major considerations, we ruled out SQL databases, which are more rigid in structure and require complex partitioning when scaling."}),"\n",(0,t.jsx)(i.p,{children:"With these in mind, we chose AWS DynamoDB. DynamoDB\u2019s ability to distribute data across multiple servers allows for smooth expansion as user bases grow, ensuring that Cerebellum-powered applications remain responsive even under heavy traffic. Its optimized read and write operations are crucial for handling the high throughput required in realtime scenarios. Moreover, DynamoDB\u2019s flexible schema supports the dynamic and evolving data models typical in realtime application development. For these reasons, DynamoDB offers an excellent blend of scalability, performance, and adaptability, making it well-suited to our needs."}),"\n",(0,t.jsx)(i.h4,{id:"availability-vs-consistency",children:"Availability vs. Consistency"}),"\n",(0,t.jsx)(i.p,{children:"With our database solution in place, we were faced with balancing availability and consistency in our realtime data interactions. This balance is essential for maintaining the responsiveness expected in realtime applications while ensuring data integrity."}),"\n",(0,t.jsx)(i.p,{children:"Direct communication between servers and databases in a realtime environment is straightforward and ensures strong consistency, but it also poses several issues:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Increased Latency:"})," Each database operation requires a round trip between the server and the database, adding delays that can be detrimental in realtime applications where milliseconds matter."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Connection Overhead:"})," Maintaining numerous open database connections for each user session can strain server and database resources, leading to inefficiencies."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Database Bottlenecks:"})," High-volume realtime applications can overwhelm databases with rapid read/write requests, potentially causing performance degradation or system failures."]}),"\n"]}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("video",{src:"/case-study/videos/Writing_to_DB.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "})}),"\n",(0,t.jsx)(i.p,{children:"While this method ensures data consistency, the resulting latency and resource strain make it less suited for realtime applications where immediate responsiveness is optimal."}),"\n",(0,t.jsx)(i.p,{children:"We implemented a queue system between the servers and the database, using AWS Simple Queue Services and AWS Lambda. This approach offers several key benefits:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Decoupling:"})," The queue buffers operations, letting the real-time server respond to clients without waiting for the database, ensuring quick responses."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Responsiveness:"})," Servers can process and acknowledge client requests promptly, meeting real-time app expectations."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Managed Load:"})," The queue controls data flow to the database, preventing performance issues from sudden write bursts."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Resilience:"})," If the database fails temporarily, the queue holds data until it's ready, minimizing data loss risk."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Eventual Consistency:"})," While not immediately consistent, the queue ensures all data is eventually processed, preserving integrity."]}),"\n"]}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("video",{src:"/case-study/videos/Writing_to_Queue.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "})}),"\n",(0,t.jsx)(i.p,{children:"When a client sends data to Cerebellum servers, the server will immediately timestamp the message and send it to the queue. The server continues to process the request without waiting for a confirmation from the database. When the message reaches the front of the queue, a serverless function will process the message and save it to the database. If the database write fails, the queue can retry the operation or save the data in the dead-letter queue\u2014a special queue where undeliverable or failed messages are sent, allowing developers to analyze and fix issues. This ensures data is not lost."}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/buildingCB_DB_and_Queue.png",className:"diagram",alt:"Architecture Diagram with API Gateway"})}),"\n",(0,t.jsx)(i.p,{children:"This approach allowed us to prioritize availability while maintaining eventual consistency. Although there is a slight delay in data persistence, this trade-off is minor compared to the performance gains. Overall, DynamoDB\u2019s fast, flexible nature proved to be an excellent choice for handling realtime workloads, even under heavy traffic. However, as data grows over time, the cost of storing vast amounts of information in DynamoDB increases significantly. To address this, we implemented a long-term solution for managing historical data without sacrificing performance or inflating costs."}),"\n",(0,t.jsx)(i.h4,{id:"archiving-data",children:"Archiving Data"}),"\n",(0,t.jsx)(i.p,{children:"As DynamoDB tables expand, older data will likely be accessed infrequently or not at all. Leaving this data in DynamoDB can add unnecessary costs to the developer."}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"Let\u2019s consider a realtime communication platform, similar to Slack. To set up this example, we make the following assumptions:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"100,000 users per day"}),"\n",(0,t.jsx)(i.li,{children:"20 messages per user per day"}),"\n",(0,t.jsx)(i.li,{children:"200 bytes per message"}),"\n",(0,t.jsx)(i.li,{children:"Archive any data older than 1 year"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This means that in a 30 day month, we would have:"}),"\n",(0,t.jsx)(i.p,{children:"100,000 users/day * 20 messages * 200 bytes/message * 30 days = 12 GB per month"}),"\n",(0,t.jsx)(i.p,{children:"AWS charges $0.25 per GB per month for DynamoDB. In our example, that would result in:"}),"\n",(0,t.jsx)(i.p,{children:"$0.25 per GB-month * 12 GB = $3 per month"}),"\n",(0,t.jsxs)(i.p,{children:["If every message was left in DynamoDB indefinitely, it would result in an ",(0,t.jsx)(i.em,{children:"additional"})," $3 per month. Over 5 years, the AWS bill for storage alone would roughly cost:"]}),"\n",(0,t.jsx)(i.p,{children:"$3 + $6 + $9 + \u2026 + $180 = $5,490"}),"\n",(0,t.jsx)(i.p,{children:"If we were to archive all messages older than 1 year, we would get a max storage per year of:"}),"\n",(0,t.jsx)(i.p,{children:"12 GB * 12 months = 144 GB/month"}),"\n",(0,t.jsx)(i.p,{children:"Paying for this across 5 years, the DynamoDB bill would be:"}),"\n",(0,t.jsx)(i.p,{children:"144 GB * 60 months * $0.25 per GB-month = $2,160"}),"\n",(0,t.jsx)(i.p,{children:"If we were archiving every month, this would be ~12GB per month. The cost of storing data in an S3 bucket is $0.023 per GB per month. This means that 1 month of storage in the S3 bucket will cost:"}),"\n",(0,t.jsx)(i.p,{children:"12 GB * $0.023 per GB-month = $0.28"}),"\n",(0,t.jsx)(i.p,{children:"As a result, this storage cost for the S3 bucket over 5 years will be:"}),"\n",(0,t.jsx)(i.p,{children:"$0.28 + $0.56 + $0.84 + \u2026 + $16.80 = $512.40"}),"\n",(0,t.jsx)(i.p,{children:"That means the total spent across 5 years would be:"}),"\n",(0,t.jsx)(i.p,{children:"$2,160 + $512.40 = $2,672.40"}),"\n",(0,t.jsx)(i.p,{children:"The cost savings from archiving data would be $2,817.60."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"It is important to remove data that is not being used in DynamoDB to save on costs in the long term. A cron job will trigger a Lambda function once per week. This Lambda will retrieve data from DynamoDB, save it as one JSON file to an AWS S3 bucket, and remove it from the DynamoDB table. The developer can define the age that data should be archived within the Lambda function."}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/buildingCB_ArchivingData.png",className:"diagram",alt:"Architecture Diagram with API Gateway"})}),"\n",(0,t.jsx)(i.h3,{id:"http-endpoint",children:"HTTP Endpoint"}),"\n",(0,t.jsxs)(i.p,{children:["Our servers could now manage both WebSocket connections and HTTP traffic, which includes messages being published from the developer's backend. However, our servers were still ",(0,t.jsx)(i.a,{href:"#challenges-with-performance",children:"tightly coupled"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"We implemented a dedicated gateway for HTTP traffic using AWS API Gateway to decouple our servers and preserve performance."}),"\n",(0,t.jsx)(i.h4,{id:"implementation-of-api-gateway-and-aws-lambda",children:"Implementation of API Gateway and AWS Lambda"}),"\n",(0,t.jsx)(i.p,{children:"AWS API Gateway is the entry point for HTTP traffic, efficiently managing API requests and routing them to the appropriate backend services. It automatically scales to handle varying traffic loads, ensuring that HTTP traffic does not interfere with WebSocket connections. Additionally, API Gateway provides built-in features such as throttling and monitoring capabilities to ensure our HTTP endpoints remain performant."}),"\n",(0,t.jsx)(i.p,{children:"AWS Lambda complements the API Gateway by enabling serverless execution of code in response to HTTP GET and POST requests. This allows us to handle various types of HTTP requests without the need to manage server infrastructure. Lambda's dynamic scalability ensures that our system adapts to changing load conditions while maintaining cost efficiency."}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/buildingCB_APIGateway.png",className:"diagram",alt:"Architecture Diagram with API Gateway"})}),"\n",(0,t.jsx)(i.p,{children:"The addition of HTTP endpoints alongside WebSocket connections expands the functionality and flexibility of our system. Key use cases for HTTP endpoints:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data Retrieval:"})," Use HTTP GET requests to fetch specific data or initialize application states without needing a persistent WebSocket connection."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Message Posting:"})," HTTP POST requests allow stateless data submissions like form entries or file uploads when realtime communication isn't needed."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Integration Opportunities:"})," API Gateway endpoints enable seamless integration with third-party services, allowing external systems to push notifications or updates to our platform."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"integration-with-dynamodb-and-other-services",children:"Integration with DynamoDB and Other Services"}),"\n",(0,t.jsx)(i.p,{children:"Modern applications frequently interact with diverse systems and services, often across various languages and frameworks. REST APIs make this integration straightforward, using standard HTTP methods (GET, POST) and widely supported data formats (JSON). This approach simplifies connecting our DynamoDB database and servers with other services, ensuring smoother and more efficient data interactions."}),"\n",(0,t.jsx)(i.h2,{id:"realtime-engineering-challenges",children:"Realtime Engineering Challenges"}),"\n",(0,t.jsx)(i.p,{children:"We had a fully formed architecture by this point, but we still needed to handle some of the common realtime application challenges."}),"\n",(0,t.jsx)(i.h3,{id:"sticky-sessions",children:"Sticky Sessions"}),"\n",(0,t.jsx)(i.p,{children:"Our WebSocket server uses Socket.io to initialize session connections, where a session is defined as a persistent WebSocket connection between the client and the server. The process of initializing a session connection is as follows:"}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("img",{src:"/case-study/photos/WebSocket_Diagram.png",className:"diagram",alt:"WebSocket Connection Handshake",width:"30%"}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 5.1: WebSocket Connection Handshake"})]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"The client sends an HTTP GET request to the server with `transport=polling` in its query parameters."}),"\n",(0,t.jsxs)(i.li,{children:["The server responds with a session ID, an array of possible transport upgrades, and other connection-related information.","\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"The session ID is used by the server to identify the client and manage the connection."}),"\n",(0,t.jsx)(i.li,{children:"The list of upgrades typically includes WebSocket as the more efficient and preferred transport method."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.li,{children:"The client will then attempt to set up HTTP long-polling as a default first option."}),"\n",(0,t.jsx)(i.li,{children:"The client will then attempt to upgrade the connection to a WebSocket connection by making a GET request with `transport=websocket` in the query parameters."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"With only one container running, this handshake process can occur without complications. A potential problem arises when we introduce a second container and a load balancer. Due to the multiple round-trip nature of establishing a WebSocket connection, a user may be routed to a container that did not create the ID and thus will not recognize it."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("video",{src:"/case-study/videos/StickySession_Bad.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 5.2: Connecting without Sticky Sessions Enabled"})]}),"\n",(0,t.jsx)(i.p,{children:"To solve this problem, we implemented \u201csticky sessions\u201d by generating a cookie with the AWS load balancer and attaching it to each client request. Each subsequent request will receive a cookie in the response and include that cookie value in its request header. The load balancer will forward each request with a recognized cookie to the same server that initially handled it, bypassing the default algorithm. This ensures that the WebSocket connection is created between the associated server and the client."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("video",{src:"/case-study/videos/StickySession_Good.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 5.3: Connecting with Sticky Sessions Enabled"})]}),"\n",(0,t.jsx)(i.h3,{id:"connection-state-recovery",children:"Connection State Recovery"}),"\n",(0,t.jsx)(i.p,{children:"Users can momentarily disconnect from a server for several reasons\u2014some common occurrences are temporary network outages or transferring from WiFi to cellular data. During this disconnection period, the user is not able to send, receive, or display the current state."}),"\n",(0,t.jsx)(i.p,{children:"Leveraging our Redis ElastiCache, we provide connection state recovery. This enables users who unexpectedly disconnect to automatically return to the same WebSocket connection, restoring their session state and avoiding re-authentication (outlined in the next section)."}),"\n",(0,t.jsx)(i.p,{children:"In practice, when the client detects a lost connection with the server, it will try to store the last received message ID. No new data can be received during the disconnection period. Upon reconnection, the ALB will redirect the client to the same server via sticky sessions. The server will recognize the WebSocket session ID and attempt to restore the state by retrieving all missed messages from the Redis ElastiCache using Redis Streams. The messages missed between the last acknowledged message ID and the current one are fetched and delivered to the client, ensuring the state is restored."}),"\n",(0,t.jsxs)("figure",{className:"image-container",children:[(0,t.jsx)("video",{src:"/case-study/videos/Connection_State_Recovery.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"rounded-lg "}),(0,t.jsx)("figcaption",{align:"center",children:"Figure 5.4: Connection State Recovery"})]}),"\n",(0,t.jsx)(i.p,{children:"An added benefit of this process is that upon disconnection, the client will also store any messages that have failed to send. Upon recovery, it will immediately send all buffered messages to the server."}),"\n",(0,t.jsx)(i.h3,{id:"authentication",children:"Authentication"}),"\n",(0,t.jsx)(i.p,{children:"In HTTP, it's easy to handle authentication because you can send credentials like tokens with every request. With WebSockets, once the connection is established during the initial handshake, you can\u2019t modify headers or send additional authentication data. This makes it difficult to manage security throughout the session since there's no built-in way to verify the user after the connection is open. To address this for Cerebellum\u2019s WebSocket servers, we implemented token-based authentication to ensure that connections remain secure and properly authenticated throughout their duration."}),"\n",(0,t.jsx)(i.h4,{id:"token-based-authentication",children:"Token-Based Authentication"}),"\n",(0,t.jsx)(i.p,{children:"A unique API key is generated with AWS Secrets when the servers are first created using our CLI. This API key is injected into every WebSocket server as an environment variable and safely retrievable in your AWS Secrets page. The API key should then be included as an environment variable on your login server."}),"\n",(0,t.jsx)(i.p,{children:"We recommend using Cerebellum SDK to generate a short-lived token using your API key upon user authentication. This process ensures that the API key remains secure on your login servers and is not exposed to clients or external parties."}),"\n",(0,t.jsx)(i.p,{children:"Cerebellum takes the following steps to secure its servers:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Token Generation:"}),(0,t.jsx)(i.br,{}),"\n","After a user logs in, the SDK generates a short-lived token tied to your API key. This token has a set expiration time to minimize misuse."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Client Authentication:"}),(0,t.jsx)(i.br,{}),"\n","When opening a WebSocket connection, the client includes the token in the first message as a temporary credential for user authentication."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Token Verification:"}),(0,t.jsx)(i.br,{}),"\n","The WebSocket server verifies the token using the API key stored in an environment variable, without needing to query the main database, boosting performance and scalability."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Handling Authentication Failures:"}),(0,t.jsx)(i.br,{}),"\n","If the token is missing or invalid, the user is denied the connection, preventing unauthorized access and helping protect against DDoS attacks."]}),"\n"]}),"\n",(0,t.jsxs)("div",{className:"flex justify-center video-container",children:[(0,t.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,t.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,t.jsx)("video",{src:"/case-study/videos/auth_bad_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:" w-full rounded-lg"})}),(0,t.jsx)("figcaption",{align:"center"})]}),(0,t.jsxs)("figure",{className:"image-container p-4 flex flex-col scaling-gif justify-center items-center",children:[(0,t.jsx)("div",{className:"flex flex-grow flex-1 bg-white items-center justify-center rounded-lg",children:(0,t.jsx)("video",{src:"/case-study/videos/auth_good_cropped.mp4",loop:!0,autoPlay:!0,muted:!0,playsInline:!0,className:"flex-grow w-full rounded-lg"})}),(0,t.jsx)("figcaption",{align:"center"})]})]}),"\n",(0,t.jsx)(i.p,{children:"By implementing this token-based authentication solution, the WebSocket servers can manage connections securely and efficiently while maintaining high performance and scalability. This approach protects the integrity of the server and ensures that only authorized users can interact with your applications."}),"\n",(0,t.jsx)(i.h3,{id:"presence",children:"Presence"}),"\n",(0,t.jsx)(i.p,{children:"In collaborative and multiplayer realtime applications, knowing who else is in the same channel or workspace is a key feature. Presence allows users to see who is active, what they\u2019re doing, and where they\u2019re working within the document."}),"\n",(0,t.jsx)(i.p,{children:"Initially, we implemented presence using a traditional pub/sub paradigm, which allowed users to broadcast their presence to others in the same channel. However, this approach had limitations. New users joining a channel could not see who was already present, leading to a lack of awareness and coordination among users. To overcome this, we needed a solution that could effectively manage and synchronize presence information across all users and servers."}),"\n",(0,t.jsx)(i.h4,{id:"utilizing-elasticache-for-presence",children:"Utilizing ElastiCache for Presence"}),"\n",(0,t.jsx)(i.p,{children:"ElastiCache with Redis OSS is an ideal solution for managing presence information in realtime applications due to its exceptional performance and low latency. Redis OSS provides an in-memory data store that supports ultra-fast data retrieval and updates, which are essential for maintaining realtime presence status. Given that Redis was already integrated into our infrastructure for the pub/sub mechanism, extending its use to handle presence data was a natural choice. Its ability to efficiently manage rapid read/write operations makes it perfect for scenarios where user presence is frequently updated. Redis\u2019 immediate consistency ensures that presence information is always current, allowing users to experience realtime changes without delay."}),"\n",(0,t.jsx)(i.p,{children:"By leveraging Redis as our single source for presence information, we can synchronize presence data across all servers. When a user joins, leaves, or updates their presence information, the changes are immediately reflected in Redis, which is accessible by all servers in the cluster. This update is then broadcasted via the pub/sub system, notifying all users subscribed to that presence channel, and providing a consistent source of presence information for all servers."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"\u2190 Show presence in chat app \u2013>"})}),"\n",(0,t.jsx)(i.h4,{id:"how-to-handle-disconnections",children:"How to Handle Disconnections"}),"\n",(0,t.jsx)(i.p,{children:"A key challenge in building presence functionality is managing user disconnections. When a client disconnects, the server must notify other users in the presence channels, as the client can no longer update its status. This prevents stale data in the Redis cache and ensures presence information stays current."}),"\n",(0,t.jsx)(i.p,{children:"To address this, we assign a unique ID to each client connected to a server. This ID is stored in Redis along with a list of all that user\u2019s presence channels. When a disconnection event is detected, the server automatically iterates through the list of that user\u2019s presence channels and notifies the corresponding presence channel that the user has left. Lastly, the server removes the user\u2019s presence information from the Redis cache to ensure it always has the most up-to-date information for everyone who joins."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"\u2190 Diagram showing disconnection? \u2013>"})}),"\n",(0,t.jsx)(i.h2,{id:"load-testing",children:"Load Testing"}),"\n",(0,t.jsx)(i.p,{children:"Our primary load-testing strategy was focused on determining how many concurrent users a server could handle. To test this, we spun up one Cerebellum WebSocket server on an AWS Fargate container and ran an Artillery test on our cloud infrastructure."}),"\n",(0,t.jsxs)(i.p,{children:["One approach when auto-scaling in ECS is to scale horizontally when the CPU or memory reaches a certain percentage. ",(0,t.jsx)(i.a,{href:"https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-configure-scaling-plan.html#:~:text=For%20example%2C%20the%20scaling%20plan,a%20different%20metric%2C%20or%20both.",children:"AWS recommends"})," scaling out at 40% to optimize for performance, 70% for cost, or 50% for a balanced optimization. Per this recommendation, we chose 50% as the default for high performance and reasonable cost efficiency."]}),"\n",(0,t.jsx)(i.h4,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Max:"})," Maximum computing resources allocated."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Baseline:"})," Percent utilization on the Fargate container immediately before the test."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Peak:"})," Percent utilization on the Fargate container at peak usage during the test."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Difference:"})," Difference between baseline and peak."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Idle user:"})," A user that connects to the server via WebSockets and does nothing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Active users:"})," A user that connects to the server via WebSockets and posts messages to a channel"]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"1-limit-of-concurrent-idle-users",children:"1) Limit of Concurrent Idle Users"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Created 1,000 idle users over 120 seconds"}),"\n",(0,t.jsx)(i.li,{children:"Recorded Peak CPU and Memory usage"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Results:"}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/load_test_idle_user.png",className:"diagram",alt:"Architecture Diagram with API Gateway"})}),"\n",(0,t.jsx)(i.h4,{id:"2-limit-of-concurrent-active-users",children:"2) Limit of Concurrent Active Users"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Created 1,000 active users over 120 seconds"}),"\n",(0,t.jsx)(i.li,{children:"Recorded Peak CPU and Memory usage"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Results:"}),"\n",(0,t.jsx)("figure",{className:"image-container",children:(0,t.jsx)("img",{src:"/case-study/photos/load_test_active.png",className:"diagram",alt:"Architecture Diagram with API Gateway"})}),"\n",(0,t.jsx)(i.h4,{id:"calculations",children:"Calculations"}),"\n",(0,t.jsx)(i.p,{children:"The limiting factor causing a container to scale is the CPU usage recorded in the idle users test. Assuming a linear relationship, we extrapolated the total number of users that trigger auto-scaling."}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"Baseline (%) + ( Difference (%) * Scaling Factor ) = Scaling Limit (%)"}),"\n",(0,t.jsx)(i.p,{children:"0.8% + (11.6% * Scaling Factor) = 50% => Scaling Factor \u2248 4.24"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Therefore, if we multiply the number of users at peak by the scaling factor, we can estimate how many concurrent users the container can handle before needing to scale."}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"1,000 * 4.24 = 4,240 users"}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"conclusion-1",children:"Conclusion"}),"\n",(0,t.jsx)(i.p,{children:"At 0.25 vCPU and 0.5 GB memory, Cerebellum\u2019s WebSocket servers will comfortably accommodate 4,240 users before auto-scaling."}),"\n",(0,t.jsx)(i.p,{children:"*These tests are not optimized to test the maximum load that could be placed on our Redis cache. Testing the Redis more extensively would include subscribing and adding presence for multiple users to one channel and testing the strain of the fanning out data and presence across that channel. This is a consideration for future load testing."}),"\n",(0,t.jsx)(i.h2,{id:"in-the-pipeline",children:"In the Pipeline..."}),"\n",(0,t.jsx)(i.h4,{id:"archived-message-retrieval",children:"Archived Message Retrieval"}),"\n",(0,t.jsx)(i.p,{children:"We\u2019ve implemented automated message archiving to reduce costs by moving older data from DynamoDB to S3. While retrieval is supported, our WebSocket server doesn\u2019t yet automate this. Developers currently handle it manually."}),"\n",(0,t.jsx)(i.h4,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,t.jsx)(i.p,{children:"In building our WebSocket infrastructure with an Application Load Balancer (ALB), we focused on scalability and ease of integration. The ALB effectively manages WebSocket connections, ensuring high availability and fault tolerance, though it lacks built-in rate-limiting capabilities\u2014an important consideration for protecting servers and ensuring fair usage."}),"\n",(0,t.jsx)(i.p,{children:"Our current setup doesn\u2019t impose rate limits on incoming WebSocket connections, leaving this aspect to be managed by external solutions or client-side throttling. While API Gateway and AWS WAF offer rate-limiting features, they introduce performance trade-offs and a need for careful cost-benefit analysis due to the complexity of configuring these services for WebSocket workloads."}),"\n",(0,t.jsx)(i.h4,{id:"elasticache-load-testing-and-failover",children:"ElastiCache: Load Testing and Failover"}),"\n",(0,t.jsx)(i.p,{children:"We have not yet tested the physical limit of our ElastiCache. Load testing should be performed by testing channel user limit and presence to determine this limit."}),"\n",(0,t.jsx)(i.p,{children:"Additionally, this single ElastiCache represents a single point of failure. Our infrastructure would benefit from designating a fallback ElastiCache in case our active ElastiCache crashes."}),"\n",(0,t.jsx)(i.h4,{id:"cloud-agnostic-offering",children:"Cloud-Agnostic Offering"}),"\n",(0,t.jsx)(i.p,{children:"AWS is our preferred cloud provider due to its extensive services and market dominance. However, we understand that other platforms like Azure and Google Cloud also have strong offerings, and some developers may prefer to consolidate resources with a different provider. While our current focus is on AWS, we acknowledge the potential benefits of a cloud-agnostic approach."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>o});var t=n(6540);const s={},a=t.createContext(s);function r(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);